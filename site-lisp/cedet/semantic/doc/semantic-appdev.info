This is semantic-appdev.info, produced by makeinfo version 4.9 from
app-dev-guide.texi.

   This manual documents Application Development with Semantic.

   Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2007, 2008
Eric M. Ludlam Copyright (C) 2001, 2002, 2003, 2004 David Ponce
Copyright (C) 2002, 2003 Richard Y. Kim

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.1 or any later version published by the Free Software
     Foundation; with the Invariant Sections being list their titles,
     with the Front-Cover Texts being list, and with the Back-Cover
     Texts being list.  A copy of the license is included in the
     section entitled "GNU Free Documentation License".

INFO-DIR-SECTION Emacs
START-INFO-DIR-ENTRY
* Semantic Application Writer's guide: (semantic-appdev).
END-INFO-DIR-ENTRY

   This file documents Application Development with Semantic.
_Infrastructure for parser based text analysis in Emacs_

   Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004 Eric M. Ludlam,
David Ponce, and Richard Y. Kim


File: semantic-appdev.info,  Node: Top,  Next: Semantic Tags,  Up: (dir)

Semantic Application Development Manual
***************************************

A semantic application takes the semantic tags generated by semantic
parsers then provides useful services to the user.  For a list of such
applications, *note the Semantic User's Guide: (semantic-user)top.

An application developer needs to know
   * when to invoke the parser to generate or regenerate the tag lists.

   * how to access the tag lists.

   * how to access information about each tag.

This chapter describes semantic functions and concepts an application
developer needs to know to perform all of the tasks just listed.

* Menu:

* Semantic Tags::
* Searching Tag Tables::        Searching tag tables.
* Tags at Point::               Finding tags at point.
* Tag Decoration::              Decorating tags
* Tag Sorting::                 Reorganizing streams.
* Tag Completion::              Completing read functions.
* Override Methods::            Language dependent functions covering
                                conversion to text strings, language dependent
                                queries and local context information
* Parser Features::             Application available parser features.
* Semantic Database::           Persistent storage of tags.
* Idle Scheduling::             Scheduling jobs in idle time.
* Example Programs::            Simple programming examples.
* Current Context::             Local context analysis.
* Data Debugger::               Application Debugger
* GNU Free Documentation License::
* Index::


File: semantic-appdev.info,  Node: Semantic Tags,  Next: Searching Tag Tables,  Prev: Top,  Up: Top

1 Semantic Tags
***************

The end result of a semantic parser is a list of tags per each buffer.
This chapter discusses the tag data structure and the API provided by
semantic to query, process, and modify tags.

The tags list for a buffer can be obtained by calling
`semantic-fetch-tags' which returns a parse tree of tags that represent
the program structure.

* Menu:

* Tag Basics::
* Tag Query::
* Tag Hooks::
* Tag Overlay::
* Misc Tag Functions::
* Tag Internals::


File: semantic-appdev.info,  Node: Tag Basics,  Next: Tag Query,  Up: Semantic Tags

1.1 Tag Basics
==============

Currently each tag is a list with up to five elements:
     (NAME CLASS ATTRIBUTES PROPERTIES OVERLAY)

Application developers should not rely on this list structure.  Instead
they should rely on the provided API documented in this chapter.  The
list structure is explained here primarily to help those reading the
semantic source code.

   * NAME is a required component for all tags, i.e., every tag must
     have this component. It is also guaranteed to be a string.  This
     string represents the name of the tag, usually a named definition
     which the language will use elsewhere as a reference to the
     syntactic element found.

   * CLASS is the other required component for all tags.  It is a
     symbol representing the class of the tag.  Valid CLASSes can be
     anything, as long is it is an Emacs Lisp symbol.  However
     following are some of the well-known symbols: `type', `function',
     `variable', `include', `package', `code'.

   * ATTRIBUTES is a property list that keep information related to the
     tag parsed from the buffer.

     The symbol names in the property list can be anything, though
     there is a useful set of predefined attributes.  It is best to use
     the API functions to access the well-known properties.  *Note Tag
     Query::.

   * PROPERTIES is generated by the semantic parser harness, and need
     not be provided by a language author.

     Properties are used to store transient data on a tag unrelated to
     the source of the original tag, such as hook functions, dynamic
     overlays, or other data needed by programs.

     The semantic incremental parser will attempt to maintain properties
     when reparsing the source of a tag.

   * OVERLAY represents positional information for this tag.  It is
     automatically generated by the semantic parser harness, and need
     not be provided by the language author.  Depending on the overlay
     in a program can be dangerous because sometimes the overlay is
     replaced with an integer pair
          [ START END ]
     when the buffer the tag belongs to is not in memory.  This happens
     when a user has activated the Semantic Database  *note
     (lang-support-guide)semanticdb::.

 -- Function: semantic-tag-name tag
     Return the name of TAG.  For functions, variables, classes,
     typedefs, etc., this is the identifier that is being defined.  For
     tags without an obvious associated name, this may be the statement
     type, e.g., this may return `print' for python's print statement.

     *Compatibility*: `semantic-tag-name' introduced in semantic
     version 2.0 supercedes `semantic-token-name' which is now obsolete.

 -- Function: semantic-tag-class tag
     Return the class of TAG.  That is, the symbol `'variable',
     `'function', `'type', or other.  There is no limit to the symbols
     that may represent the class of a tag.  Each parser generates tags
     with classes defined by it.

     For functional languages, typical tag classes are:

    `type'
          Data types, named map for a memory block.

    `function'
          A function or method, or named execution location.

    `variable'
          A variable, or named storage for data.

    `include'
          Statement that represents a file from which more tags can be
          found.

    `package'
          Statement that declares this file's package name.

    `code'
          Code that has not name or binding to any other symbol, such
          as in a script.


     *Compatibility*: `semantic-tag-class' introduced in semantic
     version 2.0 supercedes `semantic-token-token' which is now
     obsolete.

Several functions that deal with ATTRIBUTES component are given in
*Note Tag Attributes Internals: Tag Attributes Internals.  However
functions listed in *Note Tag Query: Tag Query.  should provide most
needs of the application developer.

Similarly functions that deal with PROPERTIES component are given in
*Note Tag Properties Internals: Tag Properties Internals.  The
application developer should not need to use any of these.

Finally *Note Tag Overlay: Tag Overlay. lists functions dealing with
the OVERLAY component.


File: semantic-appdev.info,  Node: Tag Query,  Next: Tag Hooks,  Prev: Tag Basics,  Up: Semantic Tags

1.2 Tag Query
=============

This section lists functions that answers simple questions regarding a
given tag.

1.2.1 Tag Predicates
--------------------

 -- Function: semantic-tag-p tag
     Return non-`nil' if TAG is most likely a semantic tag.

     *Compatibility*: `semantic-tag-p' introduced in semantic version
     2.0 supercedes `semantic-token-p' which is now obsolete.

 -- Function: semantic-equivalent-tag-p tag1 tag2
     Compare TAG1 and TAG2 and return non-`nil' if they are equivalent.
     Use "eq" to test of two tags are the same.  Use this function if
     tags are being copied and regrouped to test for if two tags
     represent the same thing, but may be constructed of different cons
     cells.

     *Compatibility*: `semantic-equivalent-tag-p' introduced in
     semantic version 2.0 supercedes `semantic-equivalent-tokens-p'
     which is now obsolete.

 -- Function: semantic-tag-similar-p tag1 tag2
     Test to see if TAG1 and TAG2 are similar.  Two tags are similar if
     their name, datatype, and various attributes are the same.

     Similar tags that have sub-tags such as arg lists or type members,
     are similar w/out checking the sub-list of tags.

 -- Function: semantic-tag-of-class-p tag class
     Return non-`nil' if class of TAG is CLASS.

 -- Function: semantic-tag-faux-p tag
     Return non-`nil' if TAG is a FAUX tag.  FAUX tags are created to
     represent a construct that is not known to exist in the code.

     Example: When the class browser sees methods to a class, but
     cannot find the class, it will create a faux tag to represent the
     class to store those methods.

 -- Function: semantic-tag-type-compound-p tag
     Return non-`nil' the type of TAG is compound.  Compound implies a
     structure or similar data type.  Returns the list of tag members
     if it is compound.

1.2.2 Documentation
-------------------

 -- Function: semantic-tag-docstring tag &optional buffer
     Return the documentation of TAG.  That is the value defined by the
     `:documentation' attribute.  Optional argument BUFFER indicates
     where to get the text from.  If not provided, then only the
     POSITION can be provided.

     *Compatibility*: `semantic-tag-docstring' introduced in semantic
     version 2.0 supercedes `semantic-token-docstring' which is now
     obsolete.

1.2.3 Common Flags
------------------

 -- Function: semantic-tag-variable-constant-p tag
     Return non-`nil' if the variable that TAG describes is a constant.
     That is the value of the attribute `:constant-flag'.

     *Compatibility*: `semantic-tag-variable-constant-p' introduced in
     semantic version 2.0 supercedes `semantic-token-variable-const'
     which is now obsolete.

 -- Function: semantic-tag-function-destructor-p tag
     Return non-`nil' if TAG describes a destructor function.  That is
     the value of the `:destructor-flag' attribute.

     *Compatibility*: `semantic-tag-function-destructor-p' introduced
     in semantic version 2.0 supercedes
     `semantic-token-function-destructor' which is now obsolete.

 -- Function: semantic-tag-function-throws tag
     Return the exceptions the function that TAG describes can throw.
     That is the value of the `:throws' attribute.

     *Compatibility*: `semantic-tag-function-throws' introduced in
     semantic version 2.0 supercedes `semantic-token-function-throws'
     which is now obsolete.

 -- Function: semantic-tag-modifiers tag
     Return the value of the `:typemodifiers' attribute of TAG.

     *Compatibility*: `semantic-tag-modifiers' introduced in semantic
     version 2.0 supercedes `semantic-token-type-modifiers' which is
     now obsolete.

     *Compatibility*: `semantic-tag-modifiers' introduced in semantic
     version 2.0 supercedes `semantic-token-variable-modifiers' which
     is now obsolete.

     *Compatibility*: `semantic-tag-modifiers' introduced in semantic
     version 2.0 supercedes `semantic-token-function-modifiers' which
     is now obsolete.

1.2.4 Functions
---------------

 -- Function: semantic-tag-function-arguments tag
     Return the arguments of the function that TAG describes.  That is
     the value of the `:arguments' attribute.

     *Compatibility*: `semantic-tag-function-arguments' introduced in
     semantic version 2.0 supercedes `semantic-token-function-args'
     which is now obsolete.

1.2.5 Variables
---------------

 -- Function: semantic-tag-variable-default tag
     Return the default value of the variable that TAG describes.  That
     is the value of the attribute `:default-value'.

     *Compatibility*: `semantic-tag-variable-default' introduced in
     semantic version 2.0 supercedes `semantic-token-variable-default'
     which is now obsolete.

1.2.6 Data Types
----------------

 -- Function: semantic-tag-type tag
     Return the value of the `:type' attribute of TAG.  For a function
     it would be the data type of the return value.  For a variable, it
     is the storage type of that variable.  For a data type, the type
     is the style of datatype, such as struct or union.

     *Compatibility*: `semantic-tag-type' introduced in semantic
     version 2.0 supercedes `semantic-token-type' which is now obsolete.

 -- Function: semantic-tag-of-type-p tag type
     Compare TAG's type against TYPE.  Non `nil' if equivalent.  TYPE
     can be a string, or a tag of class `'type'.  This can be complex
     since some tags might have a `:type' that is a tag, while other
     tags might just have a string.  This function will also be return
     true of TAG's type is compared directly to the declaration of a
     data type.

1.2.7 Inheritance and Hierarchy
-------------------------------

 -- Function: semantic-tag-named-parent tag
     Return the parent of TAG.  That is the value of the `:parent'
     attribute.  If a definition can occur outside an actual parent
     structure, but refers to that parent by name, then the `:parent'
     attribute should be used.

 -- Function: semantic-tag-function-parent tag
     Return the parent of the function that TAG describes.  That is the
     value of the `:parent' attribute.  A function has a parent if it
     is a method of a class, and if the function does not appear in
     body of it's parent class.

     *Compatibility*: `semantic-tag-function-parent' introduced in
     semantic version 2.0 supercedes `semantic-token-function-parent'
     which is now obsolete.

 -- Function: semantic-tag-type-superclasses tag
     Return the list of superclasses of the type that TAG describes.

     *Compatibility*: `semantic-tag-type-superclasses' introduced in
     semantic version 2.0 supercedes
     `semantic-token-type-parent-superclass' which is now obsolete.

     *Compatibility*: `semantic-tag-type-superclasses' introduced in
     semantic version 2.0 supercedes `semantic-token-type-parent' which
     is now obsolete.

 -- Function: semantic-tag-type-interfaces tag
     Return the list of interfaces of the type that TAG describes.

     *Compatibility*: `semantic-tag-type-interfaces' introduced in
     semantic version 2.0 supercedes
     `semantic-token-type-parent-implement' which is now obsolete.

     *Compatibility*: `semantic-tag-type-interfaces' introduced in
     semantic version 2.0 supercedes `semantic-token-type-parent' which
     is now obsolete.

 -- Function: semantic-tag-type-members tag
     Return the members of the type that TAG describes.  That is the
     value of the `:members' attribute.

     *Compatibility*: `semantic-tag-type-members' introduced in
     semantic version 2.0 supercedes `semantic-token-type-parts' which
     is now obsolete.

1.2.8 Includes
--------------

 -- Function: semantic-tag-include-system-p tag
     Return non-`nil' if the include that TAG describes is a system
     include.  That is the value of the attribute `:system-flag'.

     *Compatibility*: `semantic-tag-include-system-p' introduced in
     semantic version 2.0 supercedes `semantic-token-include-system'
     which is now obsolete.

 -- Function: semantic-tag-include-filename tag
     Return a filename representation of TAG.  The default action is to
     return the "semantic-tag-name".  Some languages do not use full
     filenames in their include statements.  Override this method to
     translate the code represenation into a filename.  (A relative
     filename if necessary.)

     See "semantic-dependency-tag-file" to expand an include tag to a
     full file name.  This function can be overloaded (see
     "define-mode-local-override" for details).

1.2.9 Code
----------

 -- Function: semantic-tag-code-detail tag
     Return detail information from code that TAG describes.  That is
     the value of the attribute `:detail'.

1.2.10 Tag Children
-------------------

 -- Function: semantic-tag-components tag
     Return a list of components for TAG.  A Component is a part of TAG
     which itself may be a TAG.  Examples include the elements of a
     structure in a tag of class `type, or the list of arguments to a
     tag of class `'function'.  This function can be overloaded (see
     "define-mode-local-override" for details).

 -- Function: semantic-tag-components-default tag
     Return a list of components for TAG.  Perform the described task
     in "semantic-tag-components".

 -- Function: semantic-tag-children-compatibility tag &optional
          positiononly
     Return children of TAG.  If POSITIONONLY is `nil', use
     "semantic-tag-components".  If POSITIONONLY is non-`nil', use
     "semantic-tag-components-with-overlays".  DO NOT use this fcn in
     new code.  Use one of the above instead.

     *Compatibility*: `semantic-tag-children-compatibility' introduced
     in semantic version 2.0 supercedes `semantic-nonterminal-children'
     which is now obsolete.


File: semantic-appdev.info,  Node: Tag Overlay,  Next: Misc Tag Functions,  Prev: Tag Hooks,  Up: Semantic Tags

1.3 Tag Overlay
===============

The functions in this answer questions regarding the overly such as the
buffer in which the tags is located, the start and/or end position of
the tag, and the overlay itself which spans the tags.

 -- Function: semantic-tag-start tag
     Return the start location of TAG.

     *Compatibility*: `semantic-tag-start' introduced in semantic
     version 2.0 supercedes `semantic-token-start' which is now
     obsolete.

 -- Function: semantic-tag-end tag
     Return the end location of TAG.

     *Compatibility*: `semantic-tag-end' introduced in semantic version
     2.0 supercedes `semantic-token-end' which is now obsolete.

 -- Function: semantic-tag-bounds tag
     Return the location (START END) of data TAG describes.

     *Compatibility*: `semantic-tag-bounds' introduced in semantic
     version 2.0 supercedes `semantic-token-extent' which is now
     obsolete.

 -- Function: semantic-tag-in-buffer-p tag
     Return the buffer TAG resides in IFF tag is already in a buffer.
     If a tag is not in a buffer, return `nil'.

 -- Function: semantic-tag-buffer tag
     Return the buffer TAG resides in.  If TAG has an originating file,
     read that file into a (maybe new) buffer, and return it.  Return
     `nil' if there is no buffer for this tag.

     *Compatibility*: `semantic-tag-buffer' introduced in semantic
     version 2.0 supercedes `semantic-token-buffer' which is now
     obsolete.

 -- Function: semantic-tag-file-name tag
     Return the name of the file from which TAG originated.  Return
     `nil' if that information can't be obtained.  If TAG is from a
     loaded buffer, then that buffer's filename is used.  If TAG is
     unlinked, but has a `:filename' property, then that is used.

 -- Function: semantic-tag-overlay tag
     Return the OVERLAY part of TAG.  That is, an overlay or an
     unloaded buffer representation.  This function can also return an
     array of the form [ START END ].  This occurs for tags that are
     not currently linked into a buffer.

     *Compatibility*: `semantic-tag-overlay' introduced in semantic
     version 2.0 supercedes `semantic-token-overlay' which is now
     obsolete.

 -- Function: semantic-tag-with-position-p tag
     Return non-`nil' if TAG has positional information.

     *Compatibility*: `semantic-tag-with-position-p' introduced in
     semantic version 2.0 supercedes `semantic-token-with-position-p'
     which is now obsolete.

 -- Function: semantic-tag-components-with-overlays tag
     Return the list of top level components belonging to TAG.
     Children are any sub-tags which contain overlays.

     Default behavior is to get "semantic-tag-components" in addition
     to the components of an anonymous types (if applicable.)

    *Language authors, please note:*
          If a mode defines a language tag that has tags in it with
          overlays you should still return them with this function.
          Ignoring this step will prevent several features from working
          correctly.  This function can be overloaded (see
          "define-mode-local-override" for details).

 -- Function: semantic-tag-components-with-overlays-default tag
     Return the list of top level components belonging to TAG.
     Children are any sub-tags which contain overlays.  The default
     action collects regular components of TAG, in addition to any
     components beloning to an anonymous type.


File: semantic-appdev.info,  Node: Tag Hooks,  Next: Tag Overlay,  Prev: Tag Query,  Up: Semantic Tags

1.4 Tag Hooks
=============

Individual tags can have hooks associated with them.  Hooks are saved
as properties, but can cause specific tags to have special behaviors
after a hook is added.

You can manipulate tag hooks with these functions:

 -- Function: semantic-tag-add-hook tag hook function &optional append
     Onto TAG, add to the value of HOOK the function FUNCTION.
     FUNCTION is added (if necessary) at the beginning of the hook list
     unless the optional argument APPEND is non-`nil', in which case
     FUNCTION is added at the end.  HOOK should be a symbol, and
     FUNCTION may be any valid function.  See also the function
     "add-hook".

 -- Function: semantic-tag-remove-hook tag hook function
     Onto TAG, remove from the value of HOOK the function FUNCTION.
     HOOK should be a symbol, and FUNCTION may be any valid function.
     If FUNCTION isn't the value of HOOK, or, if FUNCTION doesn't
     appear in the list of hooks to run in HOOK, then nothing is done.
     See also the function "remove-hook".

For a developer, if you have an application for which you want to
support a special kind of hook on a per tag basis, you can use this to
run those hooks.

 -- Function: semantic-tag-run-hooks tag hook &rest args
     Run for TAG all expressions saved on the property HOOK.  Each hook
     expression must take at least one argument, the TAG.  For any
     given situation, additional ARGS may be passed.

Semantic supports two TAG specific hooks at this time:

`link-hook'
     This hook is run whenever a tag is linked into a buffer.  This
     occurs just after parsing, and whenever a tag is loaded into
     memory.  This hook also executes after a database save, when all
     tags are first unlinked from the current buffer before the save.

`unlink-hook'
     This hook is run whenever a tag is unlinked from a buffer.  This
     occurs during a database save, or when a tag is modified by the
     incremental parser.

`unlink-copy-hook'
     This hook is run whenever a tag is copied.  This occurs in the
     function `semantic-tag-copy'.  Use this hook to remove properties
     from the tag that link it to a buffer, as this tag should no longer
     have direct buffer links.


File: semantic-appdev.info,  Node: Misc Tag Functions,  Next: Tag Internals,  Prev: Tag Overlay,  Up: Semantic Tags

1.5 Misc Tag Functions
======================

 -- Command: semantic-narrow-to-tag &optional tag
     Narrow to the region specified by the bounds of TAG.  See
     "semantic-tag-bounds".

     *Compatibility*: `semantic-narrow-to-tag' introduced in semantic
     version 2.0 supercedes `semantic-narrow-to-token' which is now
     obsolete.

 -- Function: semantic-with-buffer-narrowed-to-current-tag &rest body
     Execute BODY with the buffer narrowed to the current tag.

     *Compatibility*: `semantic-with-buffer-narrowed-to-current-tag'
     introduced in semantic version 2.0 supercedes
     `semantic-with-buffer-narrowed-to-current-token' which is now
     obsolete.

 -- Function: semantic-with-buffer-narrowed-to-tag tag &rest body
     Narrow to TAG, and execute BODY.

     *Compatibility*: `semantic-with-buffer-narrowed-to-tag' introduced
     in semantic version 2.0 supercedes
     `semantic-with-buffer-narrowed-to-token' which is now obsolete.


File: semantic-appdev.info,  Node: Tag Internals,  Prev: Misc Tag Functions,  Up: Semantic Tags

1.6 Tag Internals
=================

* Menu:

* Tag Attributes Internals::
* Tag Properties Internals::
* Tag Overlay Internals::
* Creating Tags::
* Copying Tags::
* Misc Tag Internals::


File: semantic-appdev.info,  Node: Tag Attributes Internals,  Next: Tag Properties Internals,  Up: Tag Internals

1.6.1 Tag Attributes Internals
------------------------------

 -- Function: semantic-tag-attributes tag
     Return the list of public attributes of TAG.  That is a property
     list: (ATTRIBUTE-1 VALUE-1 ATTRIBUTE-2 VALUE-2...).

     *Compatibility*: `semantic-tag-attributes' introduced in semantic
     version 2.0 supercedes `semantic-token-extra-specs' which is now
     obsolete.

     *Compatibility*: `semantic-tag-attributes' introduced in semantic
     version 2.0 supercedes `semantic-token-function-extra-specs' which
     is now obsolete.

     *Compatibility*: `semantic-tag-attributes' introduced in semantic
     version 2.0 supercedes `semantic-token-variable-extra-specs' which
     is now obsolete.

     *Compatibility*: `semantic-tag-attributes' introduced in semantic
     version 2.0 supercedes `semantic-token-type-extra-specs' which is
     now obsolete.

 -- Function: semantic-tag-get-attribute tag attribute
     From TAG, return the value of ATTRIBUTE.  ATTRIBUTE is a symbol
     whose specification value to get.  Return the value found, or
     `nil' if ATTRIBUTE is not one of the attributes of TAG.

     *Compatibility*: `semantic-tag-get-attribute' introduced in
     semantic version 2.0 supercedes `semantic-token-extra-spec' which
     is now obsolete.

     *Compatibility*: `semantic-tag-get-attribute' introduced in
     semantic version 2.0 supercedes
     `semantic-token-function-extra-spec' which is now obsolete.

     *Compatibility*: `semantic-tag-get-attribute' introduced in
     semantic version 2.0 supercedes
     `semantic-token-variable-extra-spec' which is now obsolete.

 -- Function: semantic-tag-put-attribute tag attribute value
     Change value in TAG of ATTRIBUTE to VALUE.  If ATTRIBUTE already
     exists, its value is set to VALUE, otherwise the new ATTRIBUTE
     VALUE pair is added.  Return TAG.  Use this function in a parser
     when not all attributes are known at the same time.

     *Compatibility*: `semantic-tag-put-attribute' introduced in
     semantic version 2.0 supercedes `semantic-token-add-extra-spec'
     which is now obsolete.

 -- Function: semantic-tag-put-attribute-no-side-effect tag attribute
          value
     Change value in TAG of ATTRIBUTE to VALUE without side effects.
     All cons cells in the attribute list are replicated so that there
     are no side effects if TAG is in shared lists.  If ATTRIBUTE
     already exists, its value is set to VALUE, otherwise the new
     ATTRIBUTE VALUE pair is added.  Return TAG.


File: semantic-appdev.info,  Node: Tag Properties Internals,  Next: Tag Overlay Internals,  Prev: Tag Attributes Internals,  Up: Tag Internals

1.6.2 Tag Properties Internals
------------------------------

 -- Function: semantic-tag-properties tag
     Return the list of private properties of TAG.  That is a property
     list: (PROPERTY-1 VALUE-1 PROPERTY-2 VALUE-2...).

     *Compatibility*: `semantic-tag-properties' introduced in semantic
     version 2.0 supercedes `semantic-token-properties' which is now
     obsolete.

 -- Function: semantic-tag-put-property tag property value
     Change value in TAG of PROPERTY to VALUE.  If PROPERTY already
     exists, its value is set to VALUE, otherwise the new PROPERTY
     VALUE pair is added.  Return TAG.  That function is for internal
     use only.

     *Compatibility*: `semantic--tag-put-property' introduced in
     semantic version 2.0 supercedes `semantic-token-put' which is now
     obsolete.

 -- Function: semantic-tag-get-property tag property
     From TAG, extract the value of PROPERTY.  Return the value found,
     or `nil' if PROPERTY is not one of the properties of TAG.  That
     function is for internal use only.

     *Compatibility*: `semantic--tag-get-property' introduced in
     semantic version 2.0 supercedes `semantic-token-get' which is now
     obsolete.

 -- Function: semantic-tag-put-property-no-side-effect tag property
          value
     Change value in TAG of PROPERTY to VALUE without side effects.
     All cons cells in the property list are replicated so that there
     are no side effects if TAG is in shared lists.  If PROPERTY
     already exists, its value is set to VALUE, otherwise the new
     PROPERTY VALUE pair is added.  Return TAG.  That function is for
     internal use only.

     *Compatibility*: `semantic--tag-put-property-no-side-effect'
     introduced in semantic version 2.0 supercedes
     `semantic-token-put-no-side-effect' which is now obsolete.

 -- Function: semantic-tag-make-plist args
     Create a property list with ARGS.  Args is a property list of the
     form (KEY1 VALUE1 ... KEYN VALUEN).  Where KEY is a symbol, and
     VALUE is the value for that symbol.  The return value will be a
     new property list, with these KEY/VALUE pairs eliminated:

     - KEY associated to `nil' VALUE.    - KEY associated to an empty
     string VALUE.    - KEY associated to a zero VALUE.

     *Compatibility*: `semantic-tag-make-plist' introduced in semantic
     version 2.0 supercedes `semantic-tag-make-assoc-list' which is now
     obsolete.


File: semantic-appdev.info,  Node: Tag Overlay Internals,  Next: Creating Tags,  Prev: Tag Properties Internals,  Up: Tag Internals

1.6.3 Tag Overlay Internals
---------------------------

Many of the overlay related functions were already documented in *Note
Tag Overlay: Tag Overlay.

 -- Function: semantic-tag-set-bounds tag start end
     In TAG, set the START and END location of data it describes.


File: semantic-appdev.info,  Node: Creating Tags,  Next: Copying Tags,  Prev: Tag Overlay Internals,  Up: Tag Internals

1.6.4 Creating Tags
-------------------

 -- Function: semantic-tag name class &rest attributes
     Create a generic semantic tag.  NAME is a string representing the
     name of this tag.  CLASS is the symbol that represents the class
     of tag this is, such as `'variable', or `'function'.  ATTRIBUTES
     is a list of additional attributes belonging to this tag.

     *Compatibility*: `semantic-tag' introduced in semantic version 2.0
     supercedes `semantic-token' which is now obsolete.

 -- Function: semantic-tag-new-variable name type default-value &rest
          attributes
     Create a semantic tag of class `'variable'.  NAME is the name of
     this variable.  TYPE is a string or semantic tag representing the
     type of this variable.  DEFAULT-VALUE is a string representing the
     default value of this variable.  ATTRIBUTES is a list of
     additional attributes belonging to this tag.

     *Compatibility*: `semantic-tag-new-variable' introduced in
     semantic version 2.0 supercedes `semantic-token-new-variable'
     which is now obsolete.

 -- Function: semantic-tag-new-function name type arg-list &rest
          attributes
     Create a semantic tag of class `'function'.  NAME is the name of
     this function.  TYPE is a string or semantic tag representing the
     type of this function.  ARG-LIST is a list of strings or semantic
     tags representing the arguments of this function.  ATTRIBUTES is a
     list of additional attributes belonging to this tag.

     *Compatibility*: `semantic-tag-new-function' introduced in
     semantic version 2.0 supercedes `semantic-token-new-function'
     which is now obsolete.

 -- Function: semantic-tag-new-type name type members parents &rest
          attributes
     Create a semantic tag of class `'type'.  NAME is the name of this
     type.  TYPE is a string or semantic tag representing the type of
     this type.  MEMBERS is a list of strings or semantic tags
     representing the elements that make up this type if it is a
     composite type.  PARENTS is a cons cell.  (EXPLICIT-PARENTS .
     INTERFACE-PARENTS) EXPLICIT-PARENTS can be a single string (Just
     one parent) or a list of parents (in a multiple inheritance
     situation).  It can also be `nil'.  INTERFACE-PARENTS is a list of
     strings representing the names of all INTERFACES, or abstract
     classes inherited from.  It can also be `nil'.  This slot can be
     interesting because the form:      ( `nil' "string") is a valid
     parent where there is no explicit parent, and only an interface.
     ATTRIBUTES is a list of additional attributes belonging to this
     tag.

     *Compatibility*: `semantic-tag-new-type' introduced in semantic
     version 2.0 supercedes `semantic-token-new-type' which is now
     obsolete.

 -- Function: semantic-tag-new-include name system-flag &rest attributes
     Create a semantic tag of class `'include'.  NAME is the name of
     this include.  SYSTEM-FLAG represents that we were able to
     identify this include as belonging to the system, as opposed to
     belonging to the local project.  ATTRIBUTES is a list of
     additional attributes belonging to this tag.

     *Compatibility*: `semantic-tag-new-include' introduced in semantic
     version 2.0 supercedes `semantic-token-new-include' which is now
     obsolete.

 -- Function: semantic-tag-new-package name detail &rest attributes
     Create a semantic tag of class `'package'.  NAME is the name of
     this package.  DETAIL is extra information about this package,
     such as a location where it can be found.  ATTRIBUTES is a list of
     additional attributes belonging to this tag.

     *Compatibility*: `semantic-tag-new-package' introduced in semantic
     version 2.0 supercedes `semantic-token-new-package' which is now
     obsolete.

 -- Function: semantic-tag-new-code name detail &rest attributes
     Create a semantic tag of class `'code'.  NAME is a name for this
     code.  DETAIL is extra information about the code.  ATTRIBUTES is
     a list of additional attributes belonging to this tag.


File: semantic-appdev.info,  Node: Copying Tags,  Next: Misc Tag Internals,  Prev: Creating Tags,  Up: Tag Internals

1.6.5 Copying Tags
------------------

There are two sets of tag copying features.  The first set is
`semantic-tag-clone' and `semantic-tag-copy' which are used to make
quick copies that share some detailed data with the original.

The second type is `semantic-tag-deep-copy-one-tag', which replicates
all the tags, and also allows filtering to mutate the tag.  In most
cases, a clone or copy is sufficient.

 -- Function: semantic-tag-clone tag &optional name
     Clone TAG, creating a new TAG.  If optional argument NAME is not
     `nil' it specifies a new name for the cloned tag.

     *Compatibility*: `semantic-tag-clone' introduced in semantic
     version 2.0 supercedes `semantic-clone-tag' which is now obsolete.

 -- Function: semantic-tag-copy tag &optional name keep-file
     Return a copy of TAG unlinked from the originating buffer.  If
     optional argument NAME is non-`nil' it specifies a new name for the
     copied tag.  If optional argument KEEP-FILE is non-`nil', and TAG
     was linked to a buffer, the originating buffer file name is kept
     in the `:filename' property of the copied tag.  This runs the tag
     hook `unlink-copy-hook`.

 -- Function: semantic-tag-deep-copy-one-tag tag &optional filter
     Make a deep copy of TAG, applying FILTER to each child-tag.
     Properties and overlay info are not copied.  FILTER takes TAG as
     an argument, and should returns a semantic-tag.  It is safe for
     FILTER to modify the input tag and return it.


File: semantic-appdev.info,  Node: Misc Tag Internals,  Prev: Copying Tags,  Up: Tag Internals

1.6.6 Misc Tag Internals
------------------------

 -- Function: semantic-tag-run-hooks tag hook &rest args
     Run for TAG all expressions saved on the property HOOK.  Each hook
     expression must take at least one argument, the TAG.  For any
     given situation, additional ARGS may be passed.

 -- Function: semantic-tag-unlink-from-buffer tag
     Convert TAG from using an overlay to using an overlay proxy.  This
     function is for internal use only.  This runs the tag hook
     `unlink-hook'.  *Note Tag Hooks::

 -- Function: semantic-tag-link-to-buffer tag
     Convert TAG from using an overlay proxy to using an overlay.  This
     function is for internal use only.  This runs the tag hook
     `link-hook'.  *Note Tag Hooks::

 -- Function: semantic-tag-unlink-list-from-buffer tags
     Convert TAGS from using an overlay to using an overlay proxy.
     This function is for internal use only.

 -- Function: semantic-tag-link-list-to-buffer tags
     Convert TAGS from using an overlay proxy to using an overlay.
     This function is for internal use only.

 -- Function: semantic-tag-unlink-cache-from-buffer
     Convert all tags in the current cache to use overlay proxys.  This
     function is for internal use only.

 -- Function: semantic-tag-link-cache-to-buffer
     Convert all tags in the current cache to use overlays.  This
     function is for internal use only.

 -- Function: semantic-tag-expanded-p tag
     Return non-`nil' if TAG is expanded.  This function is for
     internal use only.  See also the function `semantic--expand-tag'.

 -- Function: semantic-tag-expand tag
     Convert TAG from a raw state to a cooked state, and expand it.
     Returns a list of cooked tags.

     The parser returns raw tags with positional data START END at the
     end of the tag data structure (a list for now).  We convert it from
     that to a cooked state that uses an overlay proxy, that is, a
     vector [START END].

     The raw tag is changed with side effects and maybe expanded in
     several derived tags when the variable
     `semantic-tag-expand-function' is set.

     This function is for internal use only.


File: semantic-appdev.info,  Node: Searching Tag Tables,  Next: Tags at Point,  Prev: Semantic Tags,  Up: Top

2 Searching Tag Tables
**********************

These functions take some key, and return information found in a tag
table.  Some will return one tag (the first matching item found.)
Others will return a list of all items matching a given criterion.
Most of these functions work regardless of a buffer being in memory or
not.

Any specialty search routine that claims to use a function that is an
overload method will need to execute in a buffer of the same mode as
the tags being searched.

If you are looking for a search across multiple files, see *Note
Semantic Database::.

* Menu:

* Breadth Search::              Searching only one level of tags.
* Deep Search::                 Deep searches into types or argument lists.
* Specialty Search::            Specialty Searches.
* Custom Search::               Write custom search routines.


File: semantic-appdev.info,  Node: Breadth Search,  Next: Deep Search,  Up: Searching Tag Tables

2.1 Breadth Search
==================

Searching the breadth of a list of tags means that only one level of
the tags will be searched.  If one of the tags is a datatype with
additional members, those members are not searched.

 -- Function: semantic-find-first-tag-by-name name &optional table
     Find the first tag with NAME in TABLE.  NAME is a string.  TABLE
     is a semantic tags table.  See "semantic-something-to-tag-table".
     This routine uses "assoc" to quickly find the first matching entry.

 -- Function: semantic-find-tags-by-name name &optional table
     Find all tags with NAME in TABLE.  NAME is a string.  TABLE is a
     tag table.  See "semantic-something-to-tag-table".

 -- Function: semantic-find-tags-for-completion prefix &optional table
     Find all tags whos name begins with PREFIX in TABLE.  PREFIX is a
     string.  TABLE is a tag table.  See
     "semantic-something-to-tag-table".  While it would be nice to use
     "try-completion" or "all-completions", those functions do not
     return the tags, only a string.  Uses "compare-strings" for fast
     comparison.

 -- Function: semantic-find-tags-by-name-regexp regexp &optional table
     Find all tags with name matching REGEXP in TABLE.  REGEXP is a
     string containing a regular expression, TABLE is a tag table.  See
     "semantic-something-to-tag-table".  Consider using
     "semantic-find-tags-for-completion" if you are attempting to do
     completions.

 -- Function: semantic-find-tags-by-class class &optional table
     Find all tags of class CLASS in TABLE.  CLASS is a symbol
     representing the class of the token, such as `'variable', of
     'function..  TABLE is a tag table.  See
     "semantic-something-to-tag-table".

 -- Function: semantic-find-tags-by-type type &optional table
     Find all tags of with a type TYPE in TABLE.  TYPE is a string or
     tag representing a data type as defined in the language the tags
     were parsed from, such as "int", or perhaps a tag whose name is
     that of a struct or class.  TABLE is a tag table.  See
     "semantic-something-to-tag-table".

 -- Function: semantic-find-tags-included &optional table
     Find all tags in TABLE that are of the `'include' class.  TABLE is
     a tag table.  See "semantic-something-to-tag-table".


File: semantic-appdev.info,  Node: Deep Search,  Next: Specialty Search,  Prev: Breadth Search,  Up: Searching Tag Tables

2.2 Deep Search
===============

 -- Function: semantic-brute-find-first-tag-by-name name streamorbuffer
          &optional search-parts search-include
     Find a tag NAME within STREAMORBUFFER.  NAME is a string.  If
     SEARCH-PARTS is non-`nil', search children of tags.  If
     SEARCH-INCLUDE is non-`nil', search include files.

     Use "semantic-find-first-tag-by-name" instead.


     *Compatibility*: `semantic-brute-find-first-tag-by-name'
     introduced in semantic version 2.0 supercedes
     `semantic-find-nonterminal-by-name' which is now obsolete.

 -- Function: semantic-brute-find-tag-by-property property value
          streamorbuffer &optional search-parts search-includes
     Find all tags with PROPERTY equal to VALUE in STREAMORBUFFER.
     Optional argument SEARCH-PARTS and SEARCH-INCLUDES are passed to
     "semantic-brute-find-tag-by-function".


     *Compatibility*: `semantic-brute-find-tag-by-property' introduced
     in semantic version 2.0 supercedes
     `semantic-find-nonterminal-by-property' which is now obsolete.

 -- Function: semantic-brute-find-tag-by-attribute attr streamorbuffer
          &optional search-parts search-includes
     Find all tags with a given ATTR in STREAMORBUFFER.  ATTR is a
     symbol key into the attributes list.  Optional argument
     SEARCH-PARTS and SEARCH-INCLUDES are passed to
     "semantic-brute-find-tag-by-function".


     *Compatibility*: `semantic-brute-find-tag-by-attribute' introduced
     in semantic version 2.0 supercedes
     `semantic-find-nonterminal-by-extra-spec' which is now obsolete.

 -- Function: semantic-brute-find-tag-by-attribute-value attr value
          streamorbuffer &optional search-parts search-includes
     Find all tags with a given ATTR equal to VALUE in STREAMORBUFFER.
     ATTR is a symbol key into the attributes list.  VALUE is the value
     that ATTR should match.  Optional argument SEARCH-PARTS and
     SEARCH-INCLUDES are passed to
     "semantic-brute-find-tag-by-function".


     *Compatibility*: `semantic-brute-find-tag-by-attribute-value'
     introduced in semantic version 2.0 supercedes
     `semantic-find-nonterminal-by-extra-spec-value' which is now
     obsolete.

 -- Function: semantic-brute-find-tag-by-position position
          streamorbuffer &optional nomedian
     Find a token covering POSITION within STREAMORBUFFER.  POSITION is
     a number, or marker.  If NOMEDIAN is non-`nil', don't do the
     median calculation, and return nil.


     *Compatibility*: `semantic-brute-find-tag-by-position' introduced
     in semantic version 2.0 supercedes
     `semantic-find-nonterminal-by-position' which is now obsolete.

 -- Function: semantic-brute-find-innermost-tag-by-position position
          streamorbuffer &optional nomedian
     Find a list of tags covering POSITION within STREAMORBUFFER.
     POSITION is a number, or marker.  If NOMEDIAN is non-`nil', don't
     do the median calculation, and return nil.  This function will
     find the topmost item, and recurse until no more details are
     available of findable.


     *Compatibility*: `semantic-brute-find-innermost-tag-by-position'
     introduced in semantic version 2.0 supercedes
     `semantic-find-innermost-nonterminal-by-position' which is now
     obsolete.

 -- Function: semantic-brute-find-tag-by-class class streamorbuffer
          &optional search-parts search-includes
     Find all tags with a class CLASS within STREAMORBUFFER.  CLASS is
     a symbol representing the class of the tags to find.  See
     "semantic-tag-class".  Optional argument SEARCH-PARTS and
     SEARCH-INCLUDES are passed to
     "semantic-brute-find-tag-by-function".

     Use `semantic-find-tag-by-class' instead.


     *Compatibility*: `semantic-brute-find-tag-by-class' introduced in
     semantic version 2.0 supercedes
     `semantic-find-nonterminal-by-token' which is now obsolete.

 -- Function: semantic-brute-find-tag-standard streamorbuffer &optional
          search-parts search-includes
     Find all tags in STREAMORBUFFER which define simple class types.
     See "semantic-tag-class".  Optional argument SEARCH-PARTS and
     SEARCH-INCLUDES are passed to
     "semantic-brute-find-tag-by-function".


     *Compatibility*: `semantic-brute-find-tag-standard' introduced in
     semantic version 2.0 supercedes
     `semantic-find-nonterminal-standard' which is now obsolete.

 -- Function: semantic-brute-find-tag-by-type type streamorbuffer
          &optional search-parts search-includes
     Find all tags with type TYPE within STREAMORBUFFER.  TYPE is a
     string which is the name of the type of the tags returned.  See
     "semantic-tag-type".  Optional argument SEARCH-PARTS and
     SEARCH-INCLUDES are passed to
     "semantic-brute-find-tag-by-function".


     *Compatibility*: `semantic-brute-find-tag-by-type' introduced in
     semantic version 2.0 supercedes
     `semantic-find-nonterminal-by-type' which is now obsolete.

 -- Function: semantic-brute-find-tag-by-function function
          streamorbuffer &optional search-parts search-includes
     Find all tags for which FUNCTION's value is non-`nil' within
     STREAMORBUFFER.  FUNCTION must return non-`nil' if an element of
     STREAM will be included in the new list.

     If optional argument SEARCH-PARTS is non-`nil', all sub-parts of
     tags are searched.  The overloadable function
     `semantic-tag-componenets' is used for the searching child lists.
     If SEARCH-PARTS is the symbol `'positiononly', then only children
     that have positional information are searched.

     If SEARCH-INCLUDES is non-`nil', then all include files are also
     searched for matches.  This parameter hasn't be active for a while
     and is obsolete.


     *Compatibility*: `semantic-brute-find-tag-by-function' introduced
     in semantic version 2.0 supercedes
     `semantic-find-nonterminal-by-function' which is now obsolete.

 -- Function: semantic-brute-find-first-tag-by-function function
          streamorbuffer &optional search-parts search-includes
     Find the first tag which FUNCTION match within STREAMORBUFFER.
     FUNCTION must return non-`nil' if an element of STREAM will be
     included in the new list.

     The following parameters were never implemented.

     If optional argument SEARCH-PARTS, all sub-parts of tags are
     searched.  The overloadable function "semantic-tag-components" is
     used for searching.  If SEARCH-INCLUDES is non-`nil', then all
     include files are also searched for matches.


     *Compatibility*: `semantic-brute-find-first-tag-by-function'
     introduced in semantic version 2.0 supercedes
     `semantic-find-nonterminal-by-function-first-match' which is now
     obsolete.


File: semantic-appdev.info,  Node: Specialty Search,  Next: Custom Search,  Prev: Deep Search,  Up: Searching Tag Tables

2.3 Specialty Search
====================

There are some specialty searches needed by some semantic tools that
could prove useful.  These specialty searches often do not match
against some single attribute as most breadth searches do.

 -- Function: semantic-find-tags-of-compound-type &optional table
     Find all tags which are a compound type in TABLE.  Compound types
     are structures, or other data type which is not of a primitive
     nature, such as int or double.  Used in completion.

 -- Function: semantic-find-tags-by-scope-protection scopeprotection
          parent &optional table
     Find all tags accessible by SCOPEPROTECTION.  SCOPEPROTECTION is a
     symbol which can be returned by the method
     "semantic-tag-protection".  A hard-coded order is used to
     determine a match.  PARENT is a tag representing the PARENT slot
     needed for "semantic-tag-protection".  TABLE is a list of tags (a
     subset of PARENT members) to scan.  If TABLE is `nil', the type
     members of PARENT are used.  See "semantic-tag-protected-p" for
     details on which tags are returned.

 -- Function: semantic-find-tags-external-children-of-type type
          &optional table
     Find all tags in whose parent is TYPE in TABLE.  These tags are
     defined outside the scope of the original TYPE declaration.  TABLE
     is a tag table.  See "semantic-something-to-tag-table".


File: semantic-appdev.info,  Node: Custom Search,  Prev: Specialty Search,  Up: Searching Tag Tables

2.4 Custom Search
=================

The searching framework for semantic for tag tables has two basic root
methods.  One is a function and the other is a macro.  The functional
version is needed if some sort of macro conflict arises.  The macro
version is useful because it eliminates a level of function call, and
is faster.

 -- Function: semantic-find-tags-by-function predicate &optional table
     Find tags for which PREDICATE is non-`nil' in TABLE.  PREDICATE is
     a lambda expression which accepts on TAG.  TABLE is a semantic
     tags table.  See "semantic-something-to-tag-table".

 -- Function: semantic-find-tags-by-macro form &optional table
     Find tags for which FORM is non-`nil' in TABLE.  TABLE is a
     semantic tags table.  See "semantic-something-to-tag-table".


File: semantic-appdev.info,  Node: Tags at Point,  Next: Tag Decoration,  Prev: Searching Tag Tables,  Up: Top

3 Tags at Point
***************

When you need to get the tag the cursor is on, there is a more
efficient mechanism than using `semantic-brute-find-tag-by-position'.
This mechanism directly queries the overlays the parsing step leaves in
the buffer.  This provides for very rapid retrieval of what function or
variable the cursor is currently in.

These functions query the current buffer's overlay system for tags.

 -- Function: semantic-find-tag-by-overlay &optional positionormarker
          buffer
     Find all tags covering POSITIONORMARKER by using overlays.  If
     POSITIONORMARKER is `nil', use the current point.  Optional BUFFER
     is used if POSITIONORMARKER is a number, otherwise the current
     buffer is used.  This finds all tags covering the specified
     position by checking for all overlays covering the current spot.
     They are then sorted from largest to smallest via the start
     location.


     *Compatibility*: `semantic-find-tag-by-overlay' introduced in
     semantic version 2.0 supercedes
     `semantic-find-nonterminal-by-overlay' which is now obsolete.

 -- Function: semantic-find-tag-by-overlay-in-region start end
          &optional buffer
     Find all tags which exist in whole or in part between START and
     END.  Uses overlays to determine position.  Optional BUFFER
     argument specifies the buffer to use.


     *Compatibility*: `semantic-find-tag-by-overlay-in-region'
     introduced in semantic version 2.0 supercedes
     `semantic-find-nonterminal-by-overlay-in-region' which is now
     obsolete.

 -- Function: semantic-find-tag-by-overlay-next &optional start buffer
     Find the next tag after START in BUFFER.  If START is in an
     overlay, find the tag which starts next, not the current tag.

 -- Function: semantic-find-tag-by-overlay-prev &optional start buffer
     Find the next tag before START in BUFFER.  If START is in an
     overlay, find the tag which starts next, not the current tag.

 -- Function: semantic-current-tag
     Return the current tag in the current buffer.  If there are more
     than one in the same location, return the smallest tag.  Return
     `nil' if there is no tag here.


     *Compatibility*: `semantic-current-tag' introduced in semantic
     version 2.0 supercedes `semantic-current-nonterminal' which is now
     obsolete.

 -- Function: semantic-current-tag-parent
     Return the current tags parent in the current buffer.  A tag's
     parent would be a containing structure, such as a type containing
     a field.  Return `nil' if there is no parent.


     *Compatibility*: `semantic-current-tag-parent' introduced in
     semantic version 2.0 supercedes
     `semantic-current-nonterminal-parent' which is now obsolete.


File: semantic-appdev.info,  Node: Tag Decoration,  Next: Tag Sorting,  Prev: Tags at Point,  Up: Top

4 Tag Decoration
****************

Tags can be decorated in different ways.  One way a user can control it
is through `semantic-decoration-mode'.  *note (Tag Decoration
Mode)semantic-user::

Applications can use the same routines to decorate tags as well.

* Menu:

* Tag Highlighting::            Highlighting a tag
* Tag Visible Properties::      Invisible, intangible and read only
* Tag Secondary Overlays::      Decorating parts of a tag text
* Tag Folding::                 Visibly Folding up tags


File: semantic-appdev.info,  Node: Tag Highlighting,  Next: Tag Visible Properties,  Up: Tag Decoration

4.1 Highlighting
================

 -- Function: semantic-highlight-tag tag &optional face
     Specify that TAG should be highlighted.  Optional FACE specifies
     the face to use.

     *Compatibility*: `semantic-highlight-tag' introduced in semantic
     version 2.0 supercedes `semantic-highlight-token' which is now
     obsolete.

 -- Function: semantic-unhighlight-tag tag
     Unhighlight TAG, restoring it's previous face.

     *Compatibility*: `semantic-unhighlight-tag' introduced in semantic
     version 2.0 supercedes `semantic-unhighlight-token' which is now
     obsolete.

 -- Function: semantic-momentary-highlight-tag tag &optional face
     Highlight TAG, removing highlighting when the user hits a key.
     Optional argument FACE is the face to use for highlighting.  If
     FACE is not specified, then `highlight' will be used.

     *Compatibility*: `semantic-momentary-highlight-tag' introduced in
     semantic version 2.0 supercedes
     `semantic-momentary-highlight-token' which is now obsolete.

The highlighting routines do their work by changing the face property
of the tag overlay.  The raw routine is:

 -- Function: semantic-set-tag-face tag face
     Specify that TAG should use FACE for display.

     *Compatibility*: `semantic-set-tag-face' introduced in semantic
     version 2.0 supercedes `semantic-set-token-face' which is now
     obsolete.


File: semantic-appdev.info,  Node: Tag Visible Properties,  Next: Tag Secondary Overlays,  Prev: Tag Highlighting,  Up: Tag Decoration

4.2 Changing a tag's visible properties
=======================================

You can give a tag other properties as well, such as making it
invisible or intangible.  You can control how code is edited
programatically through these routines.

 -- Function: semantic-set-tag-invisible tag &optional visible
     Enable the text in TAG to be made invisible.  If VISIBLE is
     non-`nil', make the text visible.

     *Compatibility*: `semantic-set-tag-invisible' introduced in
     semantic version 2.0 supercedes `semantic-set-token-invisible'
     which is now obsolete.

 -- Function: semantic-tag-invisible-p tag
     Return non-`nil' if TAG is invisible.

     *Compatibility*: `semantic-tag-invisible-p' introduced in semantic
     version 2.0 supercedes `semantic-token-invisible-p' which is now
     obsolete.

 -- Function: semantic-set-tag-intangible tag &optional tangible
     Enable the text in TAG to be made intangible.  If TANGIBLE is
     non-`nil', make the text visible.  This function does not have
     meaning in XEmacs because it seems that the extent 'intangible'
     property does not exist.

     *Compatibility*: `semantic-set-tag-intangible' introduced in
     semantic version 2.0 supercedes `semantic-set-token-intangible'
     which is now obsolete.

 -- Function: semantic-tag-intangible-p tag
     Return non-`nil' if TAG is intangible.  This function does not
     have meaning in XEmacs because it seems that the extent
     'intangible' property does not exist.

     *Compatibility*: `semantic-tag-intangible-p' introduced in
     semantic version 2.0 supercedes `semantic-token-intangible-p'
     which is now obsolete.

 -- Function: semantic-set-tag-read-only tag &optional writable
     Enable the text in TAG to be made read-only.  Optional argument
     WRITABLE should be non-`nil' to make the text writable instead of
     read-only.

     *Compatibility*: `semantic-set-tag-read-only' introduced in
     semantic version 2.0 supercedes `semantic-set-token-read-only'
     which is now obsolete.

 -- Function: semantic-tag-read-only-p tag
     Return non-`nil' if the current TAG is marked read only.

     *Compatibility*: `semantic-tag-read-only-p' introduced in semantic
     version 2.0 supercedes `semantic-token-read-only-p' which is now
     obsolete.


File: semantic-appdev.info,  Node: Tag Secondary Overlays,  Next: Tag Folding,  Prev: Tag Visible Properties,  Up: Tag Decoration

4.3 Secondary Overlays
======================

Each tag which is being visited in a buffer has one overlay.  This
overlay is used to track where the tag is while a user is editing, and
can also be used for fast tag identification, and some simple
decoration techniques.

A secondary overlay associates a new overlay object with a tag which
does not cover the entire body of a tag.  You can then put visible
features on that overlay to decorate portions of a tag.  This is how
tag boundaries are drawn.

4.3.1 Creation and Deletion
---------------------------

 -- Function: semantic-tag-create-secondary-overlay tag &optional
          link-hook
     Create a secondary overlay for TAG.  Returns an overlay.  The
     overlay is also saved in TAG.  LINK-HOOK is a function called
     whenever TAG is to be linked into a buffer.  It should take TAG
     and OVERLAY as arguments.  The LINK-HOOK should be used to
     position and set properties on the generated secondary overlay.

 -- Function: semantic-tag-delete-secondary-overlay tag
          overlay-or-property
     Delete from TAG the secondary overlay OVERLAY-OR-PROPERTY.  If
     OVERLAY-OR-PROPERTY is an overlay, delete that overlay.  If
     OVERLAY-OR-PROPERTY is a symbol, find the overlay with that
     property.

4.3.2 Queries
-------------

 -- Function: semantic-tag-get-secondary-overlay tag property
     Return secondary overlays from TAG with PROPERTY.  PROPERTY is a
     symbol and all overlays with that symbol are returned..

 -- Function: semantic-tag-secondary-overlays tag
     Return a list of secondary overlays active on TAG.

4.3.3 Linking and Unlinking
---------------------------

When a tag's file is put in a buffer, that tag is "linked" into the
buffer.  When the buffer is deleted, the tag is "unlinked".  This
process adds and removes the default overlay on the tag.  Secondary
overlays use `semantic-tag-add-hook' and `semantic-tag-remove-hook' too
apply link and unlink hooks.

This allows the secondary overlays to be automatically removed or added
by the secondary overlay system whenever a tag's file goes in or out of
a buffeor.


File: semantic-appdev.info,  Node: Tag Folding,  Prev: Tag Secondary Overlays,  Up: Tag Decoration

4.4 Folding
===========

Using secondary overlays, a set of tag folding routines are made
available.  These routines are similar to the tag visible properties.

 -- Function: semantic-set-tag-folded tag &optional folded
     Fold TAG, such that only the first line of text is shown.
     Optional argument FOLDED should be non-`nil' to fold the tag.
     `nil' implies the tag should be fully shown.

 -- Function: semantic-tag-folded-p tag
     Non-`nil' if TAG is currently folded.


File: semantic-appdev.info,  Node: Tag Sorting,  Next: Tag Completion,  Prev: Tag Decoration,  Up: Top

5 Tag Sorting
*************

Sometimes it is important to reorganize a tag stream into a form that
is better for display to a user.  It is important to not use functions
with side effects that could effect the tag cache.

There are some existing utility functions which will reorganize the tag
list for you.

 -- Function: semantic-unique-tag-table tags
     Scan a list of TAGS, removing duplicates.  This must first sort
     the tags by position ascending.  TAGS are removed only if they are
     equivalent, as can happen when multiple tag sources are scanned.

 -- Function: semantic-unique-tag-table-by-name tags
     Scan a list of TAGS, removing duplicate names.  This must first
     sort the tags by name alphabetically ascending.

 -- Function: semantic-bucketize tags &optional parent filter
     Sort TAGS into a group of buckets based on tag class.  Unknown
     classes are placed in a Misc bucket.  Type bucket names are
     defined by either `semantic-symbol->name-assoc-list'.  If PARENT
     is specified, then TAGS belong to this PARENT in some way.  This
     will use `semantic-symbol->name-assoc-list-for-type-parts' to
     generate bucket names.  Optional argument FILTER is a filter
     function to be applied to each bucket.  The filter function will
     take one argument, which is a list of tokens, and may re-organize
     the list with side-effects.

 -- Variable: semantic-bucketize-tag-class
     Function used to get a symbol describing the class of a tag.  This
     function must take one argument of a semantic tag.  It should
     return a symbol found in `semantic-symbol->name-assoc-list' which
     "semantic-bucketize" uses to bin up tokens.  To create new bins
     for an application augment `semantic-symbol->name-assoc-list', and
     `semantic-symbol->name-assoc-list-for-type-parts' in addition to
     setting this variable (locally in your function).

 -- Function: semantic-adopt-external-members tags
     Rebuild TAGS so that externally defined members are regrouped.
     Some languages such as C++ and CLOS permit the declaration of
     member functions outside the definition of the class.  It is
     easier to study the structure of a program when such methods are
     grouped together more logically.

     This function uses "semantic-tag-external-member-p" to determine
     when a potential child is an externally defined member.

     Note: Applications which use this function must account for token
     types which do not have a position, but have children which *do*
     have positions.

     Applications should use `semantic-mark-external-member-function'
     to modify all tags which are found as externally defined to some
     type.  For example, changing the token type for generating extra
     buckets with the bucket function.

 -- Variable: semantic-orphaned-member-metaparent-type
     In "semantic-adopt-external-members", the type of `'type' for
     metaparents.  A metaparent is a made-up type semantic token used
     to hold the child list of orphaned members of a named type.

 -- Variable: semantic-mark-external-member-function
     Function called when an externally defined orphan is found.  By
     default, the token is always marked with the `adopted' property.
     This function should be locally bound by a program that needs to
     add additional behaviors into the token list.  This function is
     called with two arguments.  The first is TOKEN which is a shallow
     copy of the token to be modified.  The second is the PARENT which
     is adopting TOKEN.  This function should return TOKEN (or a copy
     of it) which is then integrated into the revised token list.


File: semantic-appdev.info,  Node: Tag Completion,  Next: Override Methods,  Prev: Tag Sorting,  Up: Top

6 Tag Completion
****************

Often time, it is useful to ask the user for the name of some tag.
This can be as simple as just prompting for a name, but often time, the
semantics can be quite complex.  If two tags have the same name, which
do you choose?

Semantic provides a completion engine for prompting for tags by name,
and providing fancy ways to display completion lists that allow the
user to choose a tag if several have the same name.

To use a completion function in your interactive function, you can
augment the "interactive" command like this:

     (defun my-function (tag)
        "Do something to TAG."
        (interactive (list (my-completion-function "Tag: ")))
        ...)

* Menu:

* Tag Completion Convenience Functions::  Provided functions
* Custom Tag Completion Functions::  Build your own completion function
* Old Tag Completion::          Completion functions from older releases


File: semantic-appdev.info,  Node: Tag Completion Convenience Functions,  Next: Custom Tag Completion Functions,  Up: Tag Completion

6.1 Tag Completion Convenience Functions
========================================

There are some pre written completion functions that can be used in your
programs.

 -- Function: semantic-complete-read-tag-buffer-deep prompt &optional
          default-tag initial-input history
     Ask for a tag by name from the current buffer.  Available tags are
     from the current buffer, at any level.  Completion options are
     presented in a traditional way, with highlighting to resolve
     same-name collisions.  PROMPT is a string to prompt with.
     DEFAULT-TAG is a semantic tag or string to use as the default
     value.  If INITIAL-INPUT is non-`nil', insert it in the minibuffer
     initially.  HISTORY is a symbol representing a variable to story
     the history in.

 -- Function: semantic-complete-read-tag-project prompt &optional
          default-tag initial-input history
     Ask for a tag by name from the current project.  Available tags
     are from the current project, at the top level.  Completion
     options are presented in a traditional way, with highlighting to
     resolve same-name collisions.  PROMPT is a string to prompt with.
     DEFAULT-TAG is a semantic tag or string to use as the default
     value.  If INITIAL-INPUT is non-`nil', insert it in the minibuffer
     initially.  HISTORY is a symbol representing a variable to store
     the history in.

 -- Function: semantic-complete-read-tag-analyzer prompt &optional
          context history
     Ask for a tag by name based on the current context.  The function
     "semantic-analyze-current-context" is used to calculate the
     context.  "semantic-analyze-possible-completions" is used to
     generate the list of possible completions.  PROMPT is the first
     part of the prompt.  Additional prompt is added based on the
     contexts full prefix.  CONTEXT is the semantic analyzer context to
     start with.  HISTORY is a symbol representing a variable to store
     the history in.  usually a default-tag and initial-input are
     available for completion prompts.  these are calculated from the
     CONTEXT variable passed in.

 -- Function: semantic-complete-inline-analyzer context
     Complete a symbol name by name based on the current context.  This
     is similar to `semantic-complete-read-tag-analyze', except that
     the completion interaction is in the buffer where the context was
     calculated from.  CONTEXT is the semantic analyzer context to
     start with.  See `semantic-complete-inline-tag-engine' for details
     on how completion works.


File: semantic-appdev.info,  Node: Custom Tag Completion Functions,  Next: Old Tag Completion,  Prev: Tag Completion Convenience Functions,  Up: Tag Completion

6.2 Custom Tag Completion Functions
===================================

There aren't many built in completion functions, but there are many
parts that can be put together into custom completion functions.

A completion function is built up of three important parts.

Tag Collection
     Something that selects tags, and provides some list of tags
     available, such as all functions, or all classes named "bob".

Typing and selecting
     The prompt where you can type in the name of a tag.

Displaying possible completion values
     A mechanism for displaying completion lists.

There is one typing and selecting routine that can be used to create
your custom completion prompt.

 -- Function: semantic-complete-read-tag-engine collector displayor
          prompt default-tag initial-input history
     Read a semantic tag, and return a tag for the selection.  Argument
     COLLECTOR is an object which can be used to to calculate a list of
     possible hits.  See `semantic-completion-collector-engine' for
     details on COLLECTOR.  Argumeng DISPLAYOR is an object used to
     display a list of possible completions for a given prefix.
     See`semantic-completion-display-engine' for details on DISPLAYOR.
     PROMPT is a string to prompt with.  DEFAULT-TAG is a semantic tag
     or string to use as the default value.  If INITIAL-INPUT is
     non-`nil', insert it in the minibuffer initially.  HISTORY is a
     symbol representing a variable to story the history in.

As you can see, this takes one "collector", and one "displayor".  These
are objects created for this prompt at runtime.  The completion engine
then uses to perform their tasks.

For example:

     (defun semantic-complete-read-tag-buffer-deep (prompt &optional
     						      default-tag initial-input history)
       "Ask for a tag by name from the current buffer.
     PROMPT is a string to prompt with.
     DEFAULT-TAG is a semantic tag or string to use as the default value.
     If INITIAL-INPUT is non-nil, insert it in the minibuffer initially.
     HISTORY is a symbol representing a variable to story the history in."
       (semantic-complete-read-tag-engine
        (semantic-collector-buffer-deep prompt :buffer (current-buffer))
        (semantic-displayor-traditional-with-focus-highlight "simple")
        ;;(semantic-displayor-tooltip "simple")
        prompt
        default-tag
        initial-input
        history)
       )

* Menu:

* Tag Collectors::
* Tag Displayors::


File: semantic-appdev.info,  Node: Tag Collectors,  Next: Tag Displayors,  Up: Custom Tag Completion Functions

6.2.1 Tag Collectors
--------------------

A tag collector is an object that inherits from
"semantic-collector-abstract".  A new collector is needed for each
specialized type of prompt that draws from a different selection of
tags.

You can have a collector that satisfies multiple purposes using slots
filled in the initializer for that object.

Collectors inherit from some of the following:

 -- Type: semantic-collector-abstract
     Root class for completion engines.  The baseclass provides basic
     functionality for interacting with a completion displayor object,
     and tracking the current progress of a completion.

 -- Type: semantic-collector-buffer-abstract
     Root class for per-buffer completion engines.  These collectors
     track themselves on a per-buffer basis.

 -- Type: semantic-collector-project-abstract
     Root class for project wide completion engines.  Uses semanticdb
     for searching all tags in the current project.

Available instantiable classes are:

 -- Type: semantic-collector-buffer-deep
     Completion engine for tags in the current buffer.  When searching
     for a tag, uses semantic  deep search functions.  Basics search
     only in the current buffer.

 -- Type: semantic-collector-project
     Completion engine for tags in a project.

 -- Type: semantic-collector-project-brutish
     Completion engine for tags in a project.

 -- Type: semantic-collector-analyze-completions
     Completion engine that uses the context analyzer to provide
     options.  The only options available for completion are those
     which can be logically inserted into the current context.

NOTE: Add sections for writing new collectors.


File: semantic-appdev.info,  Node: Tag Displayors,  Prev: Tag Collectors,  Up: Custom Tag Completion Functions

6.2.2 Tag Displayors
--------------------

When a user is interacting with the prompt, and requests completion,
those tags are drawn from the collector.  If the user asks for a list
of completion by hitting a complete key twice, then the list of
completions heeds to be displayed in some way.

Displayors can be used to manage the display of all tags currently
available, AND often needs to be used to focus one one particular tag
of many in a visible way.

All displayors inherit from the displayor baseclass that defines the
default behaviors:

 -- Type: semantic-displayor-abstract
     Manages the display of some number of tags.  Provides the basics
     for a displayor, including interacting with a collector, and
     tracking tables of completion to display.

 -- Type: semantic-displayor-focus-abstract
     A displayor which has the ability to focus in on one tag.
     Focusing is a way of differentiationg between multiple tags which
     have the same name.

Distinct implementations of displayors include:

 -- Type: semantic-displayor-traditional
     Traditional display mechanism for a list of possible completions.
     Completions are showin in a new buffer and listed with the ability
     to click on the items to aid in completion.

 -- Type: semantic-displayor-traditional-with-focus-highlight
     A traditional displayor which can focus on a tag by showing it.
     Same as `semantic-displayor-traditional', but with selection
     between multiple tags with the same name done by 'focusing' on the
     source location of the different tags to differentiate them.


 -- Type: semantic-displayor-tooltip
     Display mechanism using tooltip for a list of possible completions.

NOTE: Add sections for writing new collectors.


File: semantic-appdev.info,  Node: Old Tag Completion,  Prev: Custom Tag Completion Functions,  Up: Tag Completion

6.3 Older Tag Completion functions
==================================

These are older completion functions.  They may still be useful.

 -- Function: semantic-read-symbol prompt &optional default stream
          filter
     Read a symbol name from the user for the current buffer.  PROMPT
     is the prompt to use.  Optional arguments: DEFAULT is the default
     choice.  If no default is given, one is read from under point.
     STREAM is the list of tokens to complete from.  FILTER is provides
     a filter on the types of things to complete.  FILTER must be a
     function to call on each element.

 -- Function: semantic-read-variable prompt &optional default stream
     Read a variable name from the user for the current buffer.  PROMPT
     is the prompt to use.  Optional arguments: DEFAULT is the default
     choice.  If no default is given, one is read from under point.
     STREAM is the list of tokens to complete from.

 -- Function: semantic-read-function prompt &optional default stream
     Read a function name from the user for the current buffer.  PROMPT
     is the prompt to use.  Optional arguments: DEFAULT is the default
     choice.  If no default is given, one is read from under point.
     STREAM is the list of tags to complete from.

 -- Function: semantic-read-type prompt &optional default stream
     Read a type name from the user for the current buffer.  PROMPT is
     the prompt to use.  Optional arguments: DEFAULT is the default
     choice.  If no default is given, one is read from under point.
     STREAM is the list of tags to complete from.


File: semantic-appdev.info,  Node: Override Methods,  Next: Parser Features,  Prev: Tag Completion,  Up: Top

7 Override Methods
******************

"Override methods" provide generic behaviors, which a given language
can override.  For example, finding a dependency (required file) file
in Emacs lisp can be done with the `locate-library' command (which
overrides the default behavior.)  In C, a dependency (include file) can
be found by searching a generic search path which can be passed in via
a variable.

If you plan to use one of these functions from a buffer that is not of
the same major-mode as the original tag, you can use this form to make
sure the correct action takes place:

 -- Function: semantic-with-mode-bindings mode &rest body
     Evaluate BODY with the local bindings of MODE.  The current mode
     bindings are saved, BODY is evaluated, and the saved bindings are
     restored, even in case of an abnormal exit.  Value is what BODY
     returns.

For more on override methods, *note (lang-support-guide)Semantic
Overload Mechanism::.

* Menu:

* Format Tag::                  Converting Tokens into text strings
* Tag Members::                 Tags in tags
* Tag Details::                 Arbitrary token detail fetching
* Tag File Reference::	        Files a tag references.
* Jump to a Tag::	        Go to a tag's location
* Making New Methods::          How to add your own methods for your own tool


File: semantic-appdev.info,  Node: Format Tag,  Next: Tag Members,  Up: Override Methods

7.1 Format Tag
==============

Any given tag consists of Meta information which is best viewed in some
textual form.  This could be as simple as the tag's name, or as a
prototype to be added to header file in C.  Not only are there several
default converters from a Tag into text, but there is also some
convenient variables that can be used with them.  Use these variables
to allow options on output forms when displaying tags in your programs.

 -- Variable: semantic-format-tag-functions
     List of functions which convert a tag to text.  Each function must
     take the parameters TAG &optional PARENT COLOR.  TAG is the tag to
     convert.  PARENT is a parent tag or name which refers to the
     structure or class which contains TAG.  PARENT is NOT a class
     which a TAG would claim as a parent.  COLOR indicates that the
     generated text should be colored using `font-lock'.

 -- Variable: semantic-format-tag-custom-list
     A List used by customizable variables to choose a tag to text
     function.  Use this variable in the `:type' field of a
     customizable variable.

Every tag to text conversion function must take the same parameters,
which are TAG, the tag to be converted, PARENT, the containing parent
(like a structure which contains a variable), and COLOR, which is a
flag specifying that color should be applied to the returned string.

When creating, or using these strings, particularly with color, use
"concat" to build up larger strings instead of "format".  This will
preserve text properties.

 -- Function: semantic-format-tag-name tag &optional parent color
     Return the name string describing TAG.  The name is the shortest
     possible representation.  Optional argument PARENT is the parent
     type if TAG is a detail.  Optional argument COLOR means highlight
     the prototype with font-lock colors.  This function can be
     overloaded (see "define-mode-local-override" for details).

     *Compatibility*: `semantic-format-tag-name' introduced in semantic
     version 2.0 supercedes `semantic-name-nonterminal' which is now
     obsolete.

 -- Function: semantic-format-tag-abbreviate tag &optional parent color
     Return an abbreviated string describing TAG.  The abbreviation is
     to be short, with possible symbols indicating the type of tag, or
     other information.  Optional argument PARENT is the parent type if
     TAG is a detail.  Optional argument COLOR means highlight the
     prototype with font-lock colors.  This function can be overloaded
     (see "define-mode-local-override" for details).

     *Compatibility*: `semantic-format-tag-abbreviate' introduced in
     semantic version 2.0 supercedes `semantic-abbreviate-nonterminal'
     which is now obsolete.

 -- Function: semantic-format-tag-summarize tag &optional parent color
     Summarize TAG in a reasonable way.  Optional argument PARENT is
     the parent type if TAG is a detail.  Optional argument COLOR means
     highlight the prototype with font-lock colors.  This function can
     be overloaded (see "define-mode-local-override" for details).

     *Compatibility*: `semantic-format-tag-summarize' introduced in
     semantic version 2.0 supercedes `semantic-summerize-nonterminal'
     which is now obsolete.

 -- Function: semantic-format-tag-prototype tag &optional parent color
     Return a prototype for TAG.  This function should be overloaded,
     though it need not be used.  This is because it can be used to
     create code by language independent tools.  Optional argument
     PARENT is the parent type if TAG is a detail.  Optional argument
     COLOR means highlight the prototype with font-lock colors.  This
     function can be overloaded (see "define-mode-local-override" for
     details).

     *Compatibility*: `semantic-format-tag-prototype' introduced in
     semantic version 2.0 supercedes `semantic-prototype-nonterminal'
     which is now obsolete.

 -- Function: semantic-format-tag-concise-prototype tag &optional
          parent color
     Return a concise prototype for TAG.  Optional argument PARENT is
     the parent type if TAG is a detail.  Optional argument COLOR means
     highlight the prototype with font-lock colors.  This function can
     be overloaded (see "define-mode-local-override" for details).

     *Compatibility*: `semantic-format-tag-concise-prototype'
     introduced in semantic version 2.0 supercedes
     `semantic-concise-prototype-nonterminal' which is now obsolete.

 -- Function: semantic-format-tag-uml-abbreviate tag &optional parent
          color
     Return a UML style abbreviation for TAG.  Optional argument PARENT
     is the parent type if TAG is a detail.  Optional argument COLOR
     means highlight the prototype with font-lock colors.  This
     function can be overloaded (see "define-mode-local-override" for
     details).

     *Compatibility*: `semantic-format-tag-uml-abbreviate' introduced
     in semantic version 2.0 supercedes
     `semantic-uml-abbreviate-nonterminal' which is now obsolete.

 -- Function: semantic-format-tag-uml-prototype tag &optional parent
          color
     Return a UML style prototype for TAG.  Optional argument PARENT is
     the parent type if TAG is a detail.  Optional argument COLOR means
     highlight the prototype with font-lock colors.  This function can
     be overloaded (see "define-mode-local-override" for details).

     *Compatibility*: `semantic-format-tag-uml-prototype' introduced in
     semantic version 2.0 supercedes
     `semantic-uml-prototype-nonterminal' which is now obsolete.

 -- Function: semantic-format-tag-uml-concise-prototype tag &optional
          parent color
     Return a UML style concise prototype for TAG.  Optional argument
     PARENT is the parent type if TAG is a detail.  Optional argument
     COLOR means highlight the prototype with font-lock colors.  This
     function can be overloaded (see "define-mode-local-override" for
     details).

     *Compatibility*: `semantic-format-tag-uml-concise-prototype'
     introduced in semantic version 2.0 supercedes
     `semantic-uml-concise-prototype-nonterminal' which is now obsolete.

 -- Function: semantic-format-tag-prin1 tag &optional parent color
     Convert TAG to a string that is the print name for TAG.  PARENT
     and COLOR are ignored.

     *Compatibility*: `semantic-format-tag-prin1' introduced in
     semantic version 2.0 supercedes `semantic-prin1-nonterminal' which
     is now obsolete.

An additional utility will return a string for just the data type of a
tag.  This function is used in the above routines as well.

 -- Function: semantic-format-tag-type tag color
     Convert the data type of TAG to a string usable in tag formatting.
     It is presumed that TYPE is a string or semantic tag.  This
     function can be overloaded (see "define-mode-local-override" for
     details).


File: semantic-appdev.info,  Node: Tag Members,  Next: Tag Details,  Prev: Format Tag,  Up: Override Methods

7.2 Tag Members
===============

Tags are often in a hierarchical form, meaning that a tag found in the
top-level list may itself contain additional members.

The following overridable functions can fetch those tags.

 -- Function: semantic-tag-components tag
     Return a list of components for TAG.  A Component is a part of TAG
     which itself may be a TAG.  Examples include the elements of a
     structure in a tag of class `type, or the list of arguments to a
     tag of class `'function'.  This function can be overloaded (see
     "define-mode-local-override" for details).

 -- Function: semantic-tag-components-with-overlays tag
     Return the list of top level components belonging to TAG.
     Children are any sub-tags which contain overlays.

     Default behavior is to get "semantic-tag-components" in addition
     to the components of an anonymous types (if applicable.)

     Note for language authors:   If a mode defines a language tag that
     has tags in it with overlays you should still return them with
     this function.  Ignoring this step will prevent several features
     from working correctly.  This function can be overloaded (see
     "define-mode-local-override" for details).

Some languages can define parts of a tag outside the actual scope of
the parent tag.  You can fetch information about them with these
overload functions.

 -- Function: semantic-tag-external-member-p parent tag
     Return non-`nil' if PARENT is the parent of TAG.  TAG is an
     external member of PARENT when it is somehow tagged as having
     PARENT as it's parent.  PARENT and TAG must both be semantic tags.

     The default behavior, if not overridden with
     `tag-external-member-p' is to match `:parent' attribute in the
     name of TAG.

     If this function is overridden, use
     `semantic-tag-external-member-children-p-default' to also include
     the default behavior, and merely extend your own.  This function
     can be overloaded (see "define-mode-local-override" for details).

     *Compatibility*: `semantic-tag-external-member-p' introduced in
     semantic version 2.0 supercedes
     `semantic-nonterminal-external-member-p' which is now obsolete.

 -- Function: semantic-tag-external-member-children tag &optional usedb
     Return the list of children which are not *in* TAG.  If optional
     argument USEDB is non-`nil', then also search files in the
     Semantic Database.  If USEDB is a list of databases, search those
     databases.

     Children in this case are functions or types which are members of
     TAG, such as the parts of a type, but which are not defined inside
     the class.  C++ and CLOS both permit methods of a class to be
     defined outside the bounds of the class' definition.

     The default behavior, if not overridden with
     `tag-external-member-children' is to search using
     "semantic-tag-external-member-p" in all top level definitions with
     a parent of TAG.

     If this function is overridden, use
     "semantic-tag-external-member-children-default" to also include
     the default behavior, and merely extend your own.  This function
     can be overloaded (see "define-mode-local-override" for details).

     *Compatibility*: `semantic-tag-external-member-children'
     introduced in semantic version 2.0 supercedes
     `semantic-nonterminal-external-member-children' which is now
     obsolete.


File: semantic-appdev.info,  Node: Tag Details,  Next: Tag File Reference,  Prev: Tag Members,  Up: Override Methods

7.3 Tag Details
===============

These functions help derive information about tags that may not be
obvious for non-traditional languages with their own token types.

 -- Function: semantic-tag-protection tag &optional parent
     Return protection information about TAG with optional PARENT.
     This function returns on of the following symbols:    `nil'
     - No special protection.  Language dependent.     `'public'    -
     Anyone can access this TAG.     `'private'   - Only methods in the
     local scope can access TAG.     `'protected' - Like private for
     outside scopes, like public for child                 classes.
     Some languages may choose to provide additional return symbols
     specific to themselves.  Use of this function should allow for
     this.

     The default behavior (if not overridden with `tag-protection' is
     to return a symbol based on type modifiers.  This function can be
     overloaded (see "define-mode-local-override" for details).  It
     makes the overload "semantic-nonterminal-protection" obsolete.

     *Compatibility*: `semantic-tag-protection' introduced in semantic
     version 2.0 supercedes `semantic-nonterminal-protection' which is
     now obsolete.

 -- Function: semantic-tag-protected-p tag protection &optional parent
     Non-`nil' if TAG is is protected.  PROTECTION is a symbol which
     can be returned by the method "semantic-tag-protection".  PARENT
     is the parent data type which contains TAG.

     For these PROTECTIONs, true is returned if TAG is:
    `nil'
          Always true

    private
          True if `nil'.

    protected
          True if private or `nil'.

    public
          True if private, protected, or `nil'.

 -- Function: semantic-tag-abstract-p tag &optional parent
     Return non `nil' if TAG is abstract.  Optional PARENT is the
     parent tag of TAG.  In UML, abstract methods and classes have
     special meaning and behavior in how methods are overridden.  In
     UML, abstract methods are italicized.

     The default behavior (if not overridden with `tag-abstract-p' is
     to return true if `abstract' is in the type modifiers.  This
     function can be overloaded (see "define-mode-local-override" for
     details).  It makes the overload "semantic-nonterminal-abstract"
     obsolete.

     *Compatibility*: `semantic-tag-abstract-p' introduced in semantic
     version 2.0 supercedes `semantic-nonterminal-abstract' which is
     now obsolete.

 -- Function: semantic-tag-leaf-p tag &optional parent
     Return non `nil' if TAG is leaf.  Optional PARENT is the parent
     tag of TAG.  In UML, leaf methods and classes have special meaning
     and behavior.

     The default behavior (if not overridden with `tag-leaf-p' is to
     return true if `leaf' is in the type modifiers.  This function can
     be overloaded (see "define-mode-local-override" for details).  It
     makes the overload "semantic-nonterminal-leaf" obsolete.

     *Compatibility*: `semantic-tag-leaf-p' introduced in semantic
     version 2.0 supercedes `semantic-tag-leaf' which is now obsolete.

 -- Function: semantic-tag-static-p tag &optional parent
     Return non `nil' if TAG is static.  Optional PARENT is the parent
     tag of TAG.  In UML, static methods and attributes mean that they
     are allocated in the parent class, and are not instance specific.
     UML notation specifies that STATIC entries are underlined.  This
     function can be overloaded (see "define-mode-local-override" for
     details).

     *Compatibility*: `semantic-tag-static-p' introduced in semantic
     version 2.0 supercedes `semantic-tag-static' which is now obsolete.


File: semantic-appdev.info,  Node: Tag File Reference,  Next: Jump to a Tag,  Prev: Tag Details,  Up: Override Methods

7.4 Tag File Reference
======================

Some tags refer to some other file.

For include files, these options help Semantic find those files:

 -- Variable: semantic-dependency-system-include-path
     Defines the system include path.  This should be set with either
     "defvar-mode-local", or with "semantic-add-system-include".

     When searching for a file associated with a name found in an tag of
     class include, this path will be inspected for includes of type
     `system'.  Some include tags are agnostic to this setting and will
     check both the project and system directories.

 -- Function: semantic-dependency-tag-file &optional tag
     Find the filename represented from TAG.  Depends on
     `semantic-dependency-include-path' for searching.  Always searches
     `.' first, then searches additional paths.  This function can be
     overloaded (see "define-mode-local-override" for details).  It
     makes the overload "semantic-find-dependency" obsolete.

     *Compatibility*: `semantic-dependency-tag-file' introduced in
     semantic version 2.0 supercedes `semantic-find-dependency' which
     is now obsolete.

In languages with prototypes, such as C/C++, you can try to find a
corresponding file where a prototype to some implementation lives.

 -- Function: semantic-prototype-file buffer
     Return a file in which prototypes belonging to BUFFER should be
     placed.  Default behavior (if not overridden) looks for a token
     specifying the prototype file, or the existence of an EDE variable
     indicating which file prototypes belong in.  This function can be
     overloaded (see "define-mode-local-override" for details).

The semantic support for Texinfo lets you find references to functions
in doc you might be maintaining.

 -- Function: semantic-texi-find-documentation name &optional type
     Find the function or variable NAME of TYPE in the texinfo source.
     NAME is a string representing some functional symbol.  TYPE is a
     string, such as "variable" or "Command" used to find the correct
     definition in case NAME qualifies as several things.  When this
     function exists, POINT is at the definition.  If the doc was not
     found, an error is thrown.  Note: TYPE not yet implemented.


File: semantic-appdev.info,  Node: Jump to a Tag,  Next: Making New Methods,  Prev: Tag File Reference,  Up: Override Methods

7.5 Jump to a Tag
=================

Each tag has a file from which it came.  If a tag has been managed
properly, you can jump to it with this function:

 -- Function: semantic-go-to-tag tag &optional parent
     Go to the location of TAG.  TAG may be a stripped element, in
     which case PARENT specifies a parent tag that has position
     information.  Different behaviors are provided depending on the
     type of tag.  For example, dependencies (includes) will seek out
     the file that is depended on (see "semantic-dependency-tag-file".
     This function can be overloaded (see "define-mode-local-override"
     for details).  It makes the overload "semantic-find-nonterminal"
     obsolete.

     *Compatibility*: `semantic-go-to-tag' introduced in semantic
     version 2.0 supercedes `semantic-find-nonterminal' which is now
     obsolete.

When extracting tags from a database via search routines, those tags,
by default, do not have the necessary information in them.  Be sure
that when the database results are stripped, you use options that force
that file information to be kept.


File: semantic-appdev.info,  Node: Making New Methods,  Prev: Jump to a Tag,  Up: Override Methods

7.6 Making New Methods
======================

The infrastructure for creating overridable methods base on major mode
is handled by `mode-local.el' which is independent of semantic.

To create your own application specific mode local function, you should
use "define-overloadable-function".  This function creates the
framework needed for different mode-authors to customize your
applications.

Once a function has been defined as mode-local, you should use
"define-mode-local-override" to add a mode specific feature.

 -- Function: define-overloadable-function name args docstring &rest
          body
     Define a new function, as with "defun" which can be overloaded.
     NAME is the name of the function to create.  ARGS are the
     arguments to the function.  DOCSTRING is a documentation string to
     describe the function.  The docstring will automatically had
     details about its overload symbol appended to the end.  BODY is
     code that would be run when there is no override defined.  The
     default is to call the function `NAME-default' with the appropriate
     arguments.

     BODY can also include an override form that specifies which part of
     BODY is specifically overridden.  This permits to specify common
     code run for both default and overridden implementations.  An
     override form is one of:

     1. `(:override [OVERBODY])'   2. `(:override-with-args OVERARGS
     [OVERBODY])'

     OVERBODY is the code that would be run when there is no override
     defined.  The default is to call the function `NAME-default' with
     the appropriate arguments deduced from ARGS.  OVERARGS is a list
     of arguments passed to the override and `NAME-default' function,
     in place of those deduced from ARGS.

 -- Function: define-mode-local-override name mode args docstring &rest
          body
     Define a mode specific override of the function overload NAME.
     Has meaning only if NAME has been created with "define-overload".
     MODE is the major mode this override is being defined for.  ARGS
     are the function arguments, which should match those of the same
     named function created with "define-overload".  DOCSTRING is the
     documentation string.  BODY is the implementation of this function.

     *Compatibility*: `define-mode-local-override' introduced in
     semantic version 2.0 supercedes
     `define-mode-overload-implementation' which is now obsolete.

You can also create variable values that are mode local.

 -- Function: defvar-mode-local mode sym val &optional docstring
     Define MODE local variable SYM with value VAL.  DOCSTRING is
     optional.

 -- Function: defconst-mode-local mode sym val &optional docstring
     Define MODE local constant SYM with value VAL.  DOCSTRING is
     optional.

Mode local variables are implemented as buffer local.  Special hooks
enable mode-local to set these variables for the mode specified.  To
set a value as in code, you can use a special setq form.

 -- Function: setq-mode-local mode &rest args
     Assign new values to variables local in MODE.  MODE must be a
     major mode symbol.  ARGS is a list (SYM VAL SYM VAL ...).  The
     symbols SYM are variables; they are literal (not evaluated).  The
     values VAL are expressions; they are evaluated.  Set each SYM to
     the value of its VAL, locally in buffers already in MODE, or in
     buffers switched to that mode.  Return the value of the last VAL.


File: semantic-appdev.info,  Node: Parser Features,  Next: Semantic Database,  Prev: Override Methods,  Up: Top

8 Parser Features
*****************

If you write a program that uses a tag table in a persistent display or
database, it is necessary to know when tag tables change so that your
displays can be updated.  This is especially important as tags can be
replaced, changed, or deleted, and the associated overlays will then
throw errors when you try to use them.  Complete integration with tag
changes can be achieved via several hooks.

If you write an application that frequenly accesses the tags tables, it
is important to make sure those tags are up to date, and to make sure
you application does not adversely effect all the other minor modes
that may be running.

The semantic parser has many features and hooks that applications can
use to provide a good user experience.

* Menu:

* Editing Buffers::             Let the parser know you are changing a buffer.
* Parser State::                Knowing if the tag table is out of date
* Parser Hooks::                Knowing when tags change
* Lexical Safety::              Preventing lexical errors from making a mess


File: semantic-appdev.info,  Node: Editing Buffers,  Next: Parser State,  Up: Parser Features

8.1 Editing Buffers
===================

One interesting way to interact with the parser is to let it know that
changes you are going to make will not require re-parsing.

 -- Variable: semantic-edits-are-safe
     When non-`nil', modifications do not require a reparse.  This
     prevents tokens from being marked dirty, and it prevents top level
     edits from causing a cache check.  Use this when writing programs
     that could cause a full reparse, but will not change the tag
     structure, such as adding or updating top-level comments.


File: semantic-appdev.info,  Node: Parser State,  Next: Parser Hooks,  Prev: Editing Buffers,  Up: Parser Features

8.2 Parser State
================

It is sometimes useful to know what the current parsing state is.
These function can let you know what level of re-parsing may be needed.
Careful choices on when to reparse can make your program much faster.

 -- Function: semantic-parse-tree-needs-update-p
     Return non-`nil' if the current parse tree needs to be updated.

 -- Function: semantic-parse-tree-needs-rebuild-p
     Return non-`nil' if the current parse tree needs to be rebuilt.

 -- Function: semantic-parse-tree-unparseable-p
     Return non-`nil' if the current buffer has been marked unparseable.

 -- Function: semantic-parse-tree-up-to-date-p
     Return non-`nil' if the current parse tree is up to date.


File: semantic-appdev.info,  Node: Parser Hooks,  Next: Lexical Safety,  Prev: Parser State,  Up: Parser Features

8.3 Parser Hooks
================

If you just want to know when a buffer changes, use this hook.

 -- Variable: semantic-after-toplevel-cache-change-hook
     Hooks run after the buffer tag list has changed.  This list will
     change when a buffer is reparsed, or when the tag list in a buffer
     is cleared.  It is *NOT* called if the current tag list is
     partially reparsed.

     Hook functions must take one argument, which is the new list of
     tags associated with this buffer.

     For language specific hooks, make sure you define this as a local
     hook.

If you want tighter interaction with how the user is editing different
tags, you can use this hook instead.

 -- Variable: semantic-after-partial-cache-change-hook
     Hooks run after the buffer cache has been updated.

     This hook will run when the cache has been partially reparsed.
     Partial reparses are incurred when a user edits a buffer, and only
     the modified sections are rescanned.

     Hook functions must take one argument, which is the list of tokens
     updated in the current buffer.

     For language specific hooks, make sure you define this as a local
     hook.

It is also useful to clean up any data your application is using when
semantic flushes its tags table.

 -- Variable: semantic-before-toplevel-cache-flush-hook
     Hooks run before the toplevel tag cache is flushed.  For language
     specific hooks, make sure you define this as a local hook.  This
     hook is called before a corresponding
     `semantic-after-toplevel-cache-change-hook' which is also called
     during a flush when the cache is given a new value of `nil'.


File: semantic-appdev.info,  Node: Lexical Safety,  Prev: Parser Hooks,  Up: Parser Features

8.4 Lexical Safety
==================

If you application frequenly requests lists of tags upon user request,
it may be important to avoid lexical problems that frequenly occur when
the user has partially written an expression, such as starting a
string, or argument list.

You can protect your code from lexical problems with this macro:

 -- Function: semantic-lex-catch-errors symbol &rest forms
     Using SYMBOL, execute FORMS catching lexical errors.  If FORMS
     results in a call to the parser that throws a lexical error, the
     error will be caught here without the buffer's cache being thrown
     out of date.  If there is an error, the syntax that failed is
     returned.  If there is no error, then the last value of FORMS is
     returned.

It is important to provide a good SYMBOL so that these macros can nest
correctly.

If you want your code to run anyway, even if there is a lexical error,
using this macro like this:

     (semantic-lex-catch-errors
        (semantic-fetch-tags))

will put the parser into the 'unparseable' state, and allow other
routines to request the tag table without incurring additional parser
attempts.


File: semantic-appdev.info,  Node: Semantic Database,  Next: Idle Scheduling,  Prev: Parser Features,  Up: Top

9 Semantic Database
*******************

Semanticdb is a database mechanism for storing tags parsed by semantic.
The database operates in the background, saving tags as they are
parsed between sessions.  When a file is read in, and there is a
previously created set of tags available for it, semanticdb will save
time by not parsing the file, and using the cached copy.

In applications, semanticdb can provide access to the sum of all tags
in a project or in the basic system.  This database can then be
searched using a set of special routines.

* Menu:

* Semanticdb in Programs::      Basic usage.
* Semanticdb Tag Queries::      Searching for tokens in the databases.
* System Databases::            Special kinds of databases for system tags.
* Semanticdb references::       Tables can refer to eachother.


File: semantic-appdev.info,  Node: Semanticdb in Programs,  Next: Semanticdb Tag Queries,  Up: Semantic Database

9.1 Semanticdb in Programs::
============================

If you write a program using semanticdb, you will probably want to make
sure it is active in your program.

 -- Function: semanticdb-minor-mode-p
     Return non-`nil' if `semanticdb-minor-mode' is active.

Since semanticdb is optional, it is best if a program can gracefully
degrade service when semanticdb is not available, or to throw an error
letting the user know it is required to be active.

At the simplest level, you can ask if a given file is in the database,
receiving a tag table.  Semanticdb will give you an accurate set of
tags just by asking.

 -- Function: semanticdb-file-stream file
     Return a list of tags belonging to FILE.  If file has database
     tags available in the database, return them.  If file does not
     have tags available, then load the file, and create them.

Alternately, you can get the table object for a file by asking for it.

 -- Function: semanticdb-file-table-object file &optional dontload
     Return a semanticdb table belonging to FILE.  If file has database
     tags available in the database, return it.  If file does not have
     tags available, and DONTLOAD is `nil', then load the tags for
     FILE, and create a new table object for it.  DONTLOAD does not
     affect the creation of new database objects.


File: semantic-appdev.info,  Node: Semanticdb Tag Queries,  Next: System Databases,  Prev: Semanticdb in Programs,  Up: Semantic Database

9.2 Semanticdb Tag Queries
==========================

You can search for tags in the semantic database using the
semanticdb-find API.  It is important to note that database search
functions do not return a plain list of tags.  This is because some
tags may not be loaded in a buffer, which means that the found tag
would not have an overlay, and no way to determine where it came from.

As such, all search functions return a special Database Results list.

There are several types of searches, divided into groups by
implementation.  While it is possible to add new types of searches, or
write custom searches, the built in searches are usually the only ones
available in system backends *Note System Databases::.

When the term brute or brutish is used as a search criteria, that is
distinguishing between an include-path based search, and a search that
scans everything available in a project.

Non-brute force searches assume that all symbols available in a given
buffer are on the search path, or in some file that has been included,
imported, or otherwise indicated in the source file itself.  While not
always true for interpreted languages (such as Emacs Lisp), it is
common among declaritive languages.

Sometimes a brute force approach is needed, scanning every file
available to the database.  You may want to do this if your application
is collecting data unrelated to a file currently being worked on.

* Menu:

* DB Results::                  Accessing the results of a search.
* DB Search Paths::             The list of tables to search.
* DB Basic Name Search::        Searches based on name.
* DB Data Type Search::         Searches for datatypes.
* DB Basic Brute Search::       Searches on common tag attributes.
* DB Advanced Search::          Complex searches on associations
* DB Generic Search::           Do It Yourself search criteria


File: semantic-appdev.info,  Node: DB Results,  Next: DB Search Paths,  Up: Semanticdb Tag Queries

9.2.1 DB Results
----------------

The successful result of a search returns a special list of the
following form:

        ( (DATABASE TAG1 TAG2 ...) (DATABASE2 TAG3 TAG4 ...) ...)

It should not be necessary to access the results in this way, however,
as there are several routines that can be used to access this list.

To turn a semanticdb search result into a simple tag table, use:

 -- Function: semanticdb-strip-find-results results &optional
          find-file-match
     Strip a semanticdb search RESULTS to exclude objects.  This makes
     it appear more like the results of a `semantic-find-' call.
     Optional FIND-FILE-MATCH loads all files associated with RESULTS
     into buffers.  This has the side effect of enabling
     "semantic-tag-buffer" to return a value.  If the input RESULTS are
     not going to be used again, and if FIND-FILE-MATCH is `nil', you
     can use "semanticdb-fast-strip-find-results" instead.

 -- Function: semanticdb-fast-strip-find-results results
     Destructively strip a semanticdb search RESULTS to exclude objects.
     This makes it appear more like the results of a `semantic-find-'
     call.  This is like "semanticdb-strip-find-results", except the
     input list RESULTS will be changed.

To write a function that accepts a tag table, or a semanticdb search
result, use this to test if it is a semanticdb search result:

 -- Function: semanticdb-find-results-p resultp
     Non-`nil' if RESULTP is in the form of a semanticdb search result.
     This query only really tests the first entry in the list that is
     RESULTP, but should be good enough for debugging assertions.

 -- Function: semanticdb-find-result-with-nil-p resultp
     Non-`nil' of RESULTP is in the form of a semanticdb search result.
     `nil' is a valid value where a TABLE usually is, but only if the
     TAG results include overlays.  This query only really tests the
     first entry in the list that is RESULTP, but should be good enough
     for debugging assertions.

To operate on the search results as though it were a simple tags table,
or plain list, use these routines.

 -- Function: semanticdb-find-result-length result
     Number of tags found in RESULT.

 -- Function: semanticdb-find-result-nth result n
     In RESULT, return the Nth search result.  This is a 0 based search
     result, with the first match being element 0.

     The returned value is a cons cell: (TAG . TABLE) where TAG is the
     tag at the Nth position.  TABLE is the semanticdb table where the
     TAG was found.  Sometimes TABLE can be `nil'.

 -- Function: semanticdb-find-result-nth-in-buffer result n
     In RESULT, return the Nth search result.  Like
     "semanticdb-find-result-nth", except that only the TAG is
     returned, and the buffer it is found it will be made current.  If
     the result tag has no position information, the originating buffer
     is still made current.

 -- Function: semanticdb-find-result-mapc fcn result
     Apply FCN to each element of find RESULT for side-effects only.
     FCN takes two arguments.  The first is a TAG, and the second is a
     DB from whence TAG originated.  Returns result.


File: semantic-appdev.info,  Node: DB Search Paths,  Next: DB Basic Name Search,  Prev: DB Results,  Up: Semanticdb Tag Queries

9.2.2 DB Search Paths
---------------------

For searches based on an include path (non-brutish) a path of tables
needs to be generated.  Searching a lot of tables is slow, which is why
a brutish search is not always recommended.  An include-based approach
can also generate a lot of tables, so you can control how detailed a
search is with a throttle variable.

Ideally, each language mode will have a mode-specific value for this
throttle value.  A user can also specify their own values if the
default is not good enough.

 -- Variable: semanticdb-find-default-throttle
     The default throttle for `semanticdb-find' routines.  The throttle
     controls how detailed the list of database tables is for a symbol
     lookup.  The value is a list with the following keys:

    `file'
          The file the search is being performed from.  This option is
          here for completeness only, and is assumed to always be on.

    `local'
          Tables from the same local directory are included.  This
          includes files directly referenced by a file name which might
          be in a different directory.

    `project'
          Tables from the same local project are included If `project'
          is specified, then `local' is assumed.

    `unloaded'
          If a table is not in memory, load it.  If it is not cached on
          disk either, get the source, parse it, and create the table.

    `system'
          Tables from system databases.  These are specifically tables
          from system header files, or language equivalent.

    `recursive'
          For include based searches, includes tables referenced by
          included files.

    `omniscience'
          Included system databases which are omniscience, or somehow
          know everything.  Omniscience databases are found in
          `semanticdb-project-system-databases'.  The Emacs Lisp system
          DB is an omniscience database.


You can use the command `semanticdb-find-test-translate-path' to
interactively test out how the path translator is working.  The path
translation routines are:

 -- Function: semanticdb-find-translate-path path brutish
     Translate PATH into a list of semantic tables.  Path translation
     involves identifying the PATH input argument in one of the
     following ways:   `nil' - Take the current buffer, and use it's
     include list   buffer - Use that buffer's include list.
     filename - Use that file's include list.  If the file is not
     in a buffer, see of there is a semanticdb table for it.  If
     not, read that file into a buffer.    tag - Get that tag's buffer
     of file file.  See above.    table - Search that table, and it's
     include list.    find result - Search the results of a previous
     find.

     In addition, once the base path is found, there is the possibility
     of each added table adding yet more tables to the path, so this
     routine can return a lengthy list.

     If argument BRUTISH is non-`nil', then instead of using the include
     list, use all tables found in the parent project of the table
     identified by translating PATH.  Such searches use brute force to
     scan every available table.

     The return value is a list of objects of type "semanticdb-table" or
     it's children.  In the case of passing in a find result, the result
     is returned unchanged.

     This routine uses "semanticdb-find-table-for-include" to translate
     specific include tags into a semanticdb table.

     Note: When searching using a non-brutish method, the list of
     included files will be cached between runs.  Database-references
     are used to track which files need to have their include lists
     refreshed when things change.  See "semanticdb-ref-test".  This
     function can be overloaded (see "define-mode-local-override" for
     details).

 -- Function: semanticdb-find-table-for-include includetag &optional
          table
     For a single INCLUDETAG found in TABLE, find a "semanticdb-table"
     object INCLUDETAG is a semantic TAG of class `'include'.  TABLE as
     defined by "semantic-something-to-tag-table" to identify where the
     tag came from.  TABLE is optional if INCLUDETAG has an overlay of
     `:filename' attribute.  This function can be overloaded (see
     "define-mode-local-override" for details).

TODO : Make this next part show up somewhere better.

Each major mode should define their local include path with
`defcustom-mode-local-semantic-dependency-system-include-path'.  This
macro builds a customizable variable that is kept in sync with the
mode-local variable, and any include decorations that are active.

 -- Function:
defcustom-mode-local-semantic-dependency-system-include-path mode name
          value &optional docstring
     Create a mode-local value of the system-dependency include path.
     MODE is the `major-mode' this name/value pairs is for.  NAME is
     the name of the customizable value users will use.  VALUE is the
     path to add.  DOCSTRING is a documentation string applied to the
     variable NAME users will customize.

     Creates a customizable variable users can customize that will keep
     semantic data structures up to date.


File: semantic-appdev.info,  Node: DB Basic Name Search,  Next: DB Data Type Search,  Prev: DB Search Paths,  Up: Semanticdb Tag Queries

9.2.3 DB Basic Name Search
--------------------------

These searches scan a database table collection for tags based on name.
They are divided into normal and deep searches.  A deep search, as
with in buffer tag scanning, implies that all entries are scanned,
including those in type declarations.

Normal Searches:

 -- Function: semanticdb-find-tags-by-name name &optional path
          find-file-match
     Search for all tags matching NAME on PATH.  See
     "semanticdb-find-translate-path" for details on PATH.
     FIND-FILE-MATCH indicates that any time a match is found, the file
     associated with that tag should be loaded into a buffer.

 -- Function: semanticdb-find-tags-by-name-regexp regexp &optional path
          find-file-match
     Search for all tags matching REGEXP on PATH.  See
     "semanticdb-find-translate-path" for details on PATH.
     FIND-FILE-MATCH indicates that any time a match is found, the file
     associated with that tag should be loaded into a buffer.

 -- Function: semanticdb-find-tags-for-completion prefix &optional path
          find-file-match
     Search for all tags matching PREFIX on PATH.  See
     "semanticdb-find-translate-path" for details on PATH.
     FIND-FILE-MATCH indicates that any time a match is found, the file
     associated with that tag should be loaded into a buffer.

 -- Function: semanticdb-find-tags-by-class class &optional path
          find-file-match
     Search for all tags of CLASS on PATH.  See
     "semanticdb-find-translate-path" for details on PATH.
     FIND-FILE-MATCH indicates that any time a match is found, the file
     associated with that tag should be loaded into a buffer.

Deep Searches:

 -- Function: semanticdb-deep-find-tags-by-name name &optional path
          find-file-match
     Search for all tags matching NAME on PATH.  Search also in all
     components of top level tags founds.  See
     "semanticdb-find-translate-path" for details on PATH.
     FIND-FILE-MATCH indicates that any time a match is found, the file
     associated with that tag should be loaded into a buffer.

 -- Function: semanticdb-deep-find-tags-by-name-regexp regexp &optional
          path find-file-match
     Search for all tags matching REGEXP on PATH.  Search also in all
     components of top level tags founds.  See
     "semanticdb-find-translate-path" for details on PATH.
     FIND-FILE-MATCH indicates that any time a match is found, the file
     associated with that tag should be loaded into a buffer.

 -- Function: semanticdb-deep-find-tags-for-completion prefix &optional
          path find-file-match
     Search for all tags matching PREFIX on PATH.  Search also in all
     components of top level tags founds.  See
     "semanticdb-find-translate-path" for details on PATH.
     FIND-FILE-MATCH indicates that any time a match is found, the file
     associated with that tag should be loaded into a buffer.


File: semantic-appdev.info,  Node: DB Data Type Search,  Next: DB Basic Brute Search,  Prev: DB Basic Name Search,  Up: Semanticdb Tag Queries

9.2.4 DB Data Type Search
-------------------------

In typed languages, datatypes are looked up frequently in order to
provide smart completions.  Semantic has a specialized datatype search
that builds a cache of all datatypes on the include path.  Once this is
built the first time, datatype lookups become very fast.

Since it takes a long time to make a typecache the first time, you can
have your tool decide if it wants to do work based on the existence of
a typecache.

 -- Function: semanticdb-have-typecache-p table
     Return non-`nil' (the typecache) if TABLE has a pre-calculated
     typecache.

 -- Function: semanticdb-get-typecache table
     Retrieve the typecache from the semanticdb TABLE.  If there is no
     table, create one, and fill it in.

Searching doesn't require a typecache.  You can just pass in a database
table, or path, much the way most semantic database searches work.

 -- Function: semanticdb-typecache-find type &optional path
     Search the typecache for TYPE in PATH.  If type is a string, split
     the string, and search for the parts.  If type is a list, treat
     the type as a pre-split string.  PATH can be `nil' for the current
     buffer, or a semanticdb table.  This function can be overloaded
     (see "define-mode-local-override" for details).

You can debug the typecache with this routine:

 -- Command: semanticdb-typecache-dump
     Dump the typecache for the current buffer.


File: semantic-appdev.info,  Node: DB Basic Brute Search,  Next: DB Advanced Search,  Prev: DB Data Type Search,  Up: Semanticdb Tag Queries

9.2.5 DB Basic Brute Search
---------------------------

These searches allow searching on specific attributes of tags,  such as
name, type, or other attribute.

 -- Function: semanticdb-brute-deep-find-tags-by-name name &optional
          path find-file-match
     Search for all tags matching NAME on PATH.  See
     "semanticdb-find-translate-path" for details on PATH.  The
     argument BRUTISH will be set so that searching includes all tables
     in the current project.  FIND-FILE-MATCH indicates that any time a
     matchi is found, the file associated wit that tag should be loaded
     into a buffer.


File: semantic-appdev.info,  Node: DB Advanced Search,  Next: DB Generic Search,  Prev: DB Basic Brute Search,  Up: Semanticdb Tag Queries

9.2.6 DB Advanced Search
------------------------

These are searches that were needed to accomplish some  specialized
tasks as discovered in utilities.  Advanced searches  include matching
methods defined outside some parent class.

The reason for advanced searches are so that external  repositories
such as the Emacs obarray, or java `.class' files can  quickly answer
these needed questions without dumping the entire  symbol list into
Emacs for a regular semanticdb search.

 -- Function: semanticdb-find-tags-external-children-of-type type
          &optional path find-file-match
     Search for all tags defined outside of TYPE w/ TYPE as a parent.
     See "semanticdb-find-translate-path" for details on PATH.
     FIND-FILE-MATCH indicates that any time a match is found, the file
     associated with that tag should be loaded into a buffer.


File: semantic-appdev.info,  Node: DB Generic Search,  Prev: DB Advanced Search,  Up: Semanticdb Tag Queries

9.2.7 DB Generic Search
-----------------------

If you would like to write your own search routine, you can the generic
tag collector.  It will map your function across valid semantic
databases.

 -- Function: semanticdb-find-tags-collector function &optional path
          find-file-match brutish
     Collect all tags returned by FUNCTION over PATH.  The FUNCTION
     must take two arguments.  The first is TABLE, which is a
     semanticdb table containing tags.  The second argument to FUNCTION
     is TAGS.  TAGS may be a list of tags.  If TAGS is non-`nil', then
     FUNCTION should search the TAG list, not through TABLE.

     See "semanticdb-find-translate-path" for details on PATH.
     FIND-FILE-MATCH indicates that any time a match is found, the file
     associated with that tag should be loaded into a buffer.

     Note: You should leave FIND-FILE-MATCH as `nil'.  It is far more
     efficient to take the results from any search and use
     "semanticdb-strip-find-results" instead.  This argument is here
     for backward compatibility.

     If optional argument BRUTISH is non-`nil', then ignore include
     statements, and search all tables in this project tree.


File: semantic-appdev.info,  Node: System Databases,  Next: Semanticdb references,  Prev: Semanticdb Tag Queries,  Up: Semantic Database

9.3 System Databases
====================

System Databases are special implementations of the database and table
API which make some external tag source appear as though it were a
normal buffer with semantic parsed tags available.

Search routines for these databases return a special type of table not
associated with a file.  It is important to be aware of this possible
return value.

 -- Type: semanticdb-project-database-emacs-lisp
     Database representing Emacs core.

This Emacs database is loaded automatically.

 -- Type: semanticdb-project-database-ebrowse
     Semantic Database deriving tags using the EBROWSE tool.  EBROWSE
     is a C/C++ parser for use with `ebrowse' Emacs program.

To create new EBROWSE project databases, use:

 -- Command: semanticdb-create-ebrowse-database dir
     Create an EBROWSE database for directory DIR.  The database file
     is stored in ~/.semanticdb, or whichever directory is specified by
     `semanticdb-default-system-save-directory'.


File: semantic-appdev.info,  Node: Semanticdb references,  Prev: System Databases,  Up: Semantic Database

9.4 Semanticdb References
=========================

Semantic database can keep references to eachother.  The semanticdb
search routine `semanticdb-find-translate-path' will keep the
references up-to date whenever you do a semanticdb search.  Whenever a
buffer is reparsed, all caches are synchronized through the reference
tables.

The reference mechanism will let you identify references in either
direction.

This routine will return a list of TAGS that refer to some database.
Use the routine `semanticdb-find-table-for-include' to conver these
include tags into tables.

 -- Function: semanticdb-includes-in-table dbt
     Return a list of direct includes in table DBT.

To run a function against all semantic tables that refer to the current
table, use this routine:

 -- Function: semanticdb-notify-references dbt method
     Notify all references of the table DBT using method.  METHOD takes
     two arguments.    (METHOD TABLE-TO-NOTIFY DBT) TABLE-TO-NOTIFY is
     a semanticdb-table which is being notified.  DBT, the second
     argument is DBT.

The following routines will help keep things up-to-date:

 -- Function: semanticdb-check-references dbt
     Check and cleanup references in the database DBT.  Any reference
     to a file that cannot be found, or whos file no longer refers to
     DBT will be removed.

To debug references, use this routine:

 -- Command: semanticdb-ref-test refresh
     Dump out the list of references for the current buffer.  If
     REFRESH is non-`nil', cause the current table to have it's
     references refreshed before dumping the result.


File: semantic-appdev.info,  Node: Idle Scheduling,  Next: Example Programs,  Prev: Semantic Database,  Up: Top

10 Idle Scheduling
******************

The Semantic Idle Scheduler is a minor mode which performs semantic
specific tasks in idle time.  See *note (semantic-user.info)Idle
Scheduler::.

It performs the following tasks in order:

  1. Reprarse the current buffer if needed

  2. Reparse other buffers that need it

  3. Execute other scheduled semantic related operations.

Care is take in the idle scheduler to exit immediately if user input is
detected, improving editing performance.

The reason for grouping these tasks together is so that the automatic
reparsing code executes before other idle services.  This allows
lexically broken buffers to be detected so that the other applications
that follow do not accidentally reparse the buffer leaving unmatched
syntax all over.

You can create new minor modes that are automatically scheduled by the
semantic idle scheduler.  Create the new minor mode with:

 -- Function: define-semantic-idle-service name doc &rest forms
     Create a new idle services with NAME.  DOC will be a documentation
     string describing FORMS.  FORMS will be called during idle time
     after the current buffer's semantic tag information has been
     updated.  This routines creates the following functions and
     variables:

10.1 User Input Handling
========================

When writing an idle service, it is important for tasks that can take a
long time to correctly exit upon user input.

You can test for user input in your idle handler with the following
routines:

 -- Function: semantic-throw-on-input from
     Exit with "throw" when in "semantic-exit-on-input" on user input.
     FROM is an indication of where this function is called from as a
     value to pass to "throw".  It is recommended to use the name of
     the function calling this one.

If you need to carefully extract from your function, you can wrap just
a section of your function to exit on user input by wrapping it with
this macro:

 -- Function: semantic-exit-on-input symbol &rest forms
     Using SYMBOL as an argument to "throw", execute FORMS.  If FORMS
     includes a call to `semantic-thow-on-input', then if a user
     presses any key during execution, this form macro will exit with
     the value passed to "semantic-throw-on-input".  If FORMS
     completes, then the return value is the same as "progn".

Upon catching user input, you can try to detect if there was an exit
from the return argument, and continue throwing with an additional call
to `semantic-throw-on-input'.


File: semantic-appdev.info,  Node: Example Programs,  Next: Current Context,  Prev: Idle Scheduling,  Up: Top

11 Programming Examples
***********************

*** NOTE ***  This section needs to be written


File: semantic-appdev.info,  Node: Current Context,  Next: Data Debugger,  Prev: Example Programs,  Up: Top

12 Deriving the Current Context
*******************************

This chapter deals with how to derive the current context, and also how
a language maintainer can get the current context API to work with
their language.

By default, the behavior will function in C like languages.  This means
languages with parenthetical blocks, and type dereferencing which uses
a similar form.

* Menu:

* Blocks::
* Local Variables::             Getting lists of local variables.
* Derived Context::             What goes at a given location?
* Context Analysis::            Analysis information about the local context.


File: semantic-appdev.info,  Node: Blocks,  Next: Local Variables,  Up: Current Context

12.1 Blocks and Navigation
==========================

Source code is typically built up of control structures, and blocks of
context, or lexical scope.  Semantic terms these lexical scopes as a
"context".  The following functions can be used to navigate contexts.
Some of them are override functions.  Language authors can override a
subset of them to make them work for their language.

 -- Function: semantic-up-context &optional point bounds-type
     Move point up one context from POINT.  Return non-`nil' if there
     are no more context levels.  Overloaded functions using
     `up-context' take no parameters.  BOUNDS-TYPE is a symbol
     representing a tag class to restrict movement to.  If this is
     `nil', `'function' is used.  This will find the smallest tag of
     that class (function, variable, type, etc) and make sure non-`nil'
     is returned if you cannot go up past the bounds of that tag.  This
     function can be overloaded (see "define-mode-local-override" for
     details).

 -- Function: semantic-beginning-of-context &optional point
     Move POINT to the beginning of the current context.  Return
     non-`nil' if there is no upper context.  The default behavior uses
     "semantic-up-context".  This function can be overloaded (see
     "define-mode-local-override" for details).

 -- Function: semantic-end-of-context &optional point
     Move POINT to the end of the current context.  Return non-`nil' if
     there is no upper context.  Be default, this uses
     "semantic-up-context", and assumes parenthetical block delimiters.
     This function can be overloaded (see "define-mode-local-override"
     for details).

These next set of functions can be used to navigate across commands.

 -- Function: semantic-end-of-command
     Move to the end of the current command.  Be default, uses
     `semantic-command-separation-character'.  This function can be
     overloaded (see "define-mode-local-override" for details).

 -- Function: semantic-beginning-of-command
     Move to the beginning of the current command.  Be default, uses
     `semantic-command-separation-character'.  This function can be
     overloaded (see "define-mode-local-override" for details).


File: semantic-appdev.info,  Node: Local Variables,  Next: Derived Context,  Prev: Blocks,  Up: Current Context

12.2 Deriving local variables
=============================

Within a given context, or block of code, local variables are often
defined.  These functions can be used to retrieve lists of locally
scoped variables.

 -- Function: semantic-get-local-variables &optional point
     Get the local variables based on POINT's context.  Local variables
     are returned in Semantic tag format.  This can be overriden with
     `get-local-variables'.  This function can be overloaded (see
     "define-mode-local-override" for details).

 -- Function: semantic-get-local-arguments &optional point
     Get arguments (variables) from the current context at POINT.
     Parameters are available if the point is in a function or method.
     Return a list of tags unlinked from the originating buffer.
     Arguments are obtained by overriding `get-local-arguments', or by
     the default function "semantic-get-local-arguments-default".
     This, must return a list of tags, or a list of strings that will
     be converted to tags.  This function can be overloaded (see
     "define-mode-local-override" for details).

 -- Function: semantic-get-all-local-variables &optional point
     Get all local variables for this context, and parent contexts.
     Local variables are returned in Semantic tag format.  Be default,
     this gets local variables, and local arguments.  Optional argument
     POINT is the location to start getting the variables from.  This
     function can be overloaded (see "define-mode-local-override" for
     details).


File: semantic-appdev.info,  Node: Derived Context,  Next: Context Analysis,  Prev: Local Variables,  Up: Current Context

12.3 Deriving the Current Context
=================================

While a context has already been used to describe blocks of code, other
context include more local details, such as the symbol the cursor is
on, or the fact we are assigning into some other variable.

These context deriving functions can be overridden to provide language
specific behavior.  By default, it assumes a C like language.

 -- Function: semantic-ctxt-current-symbol &optional point
     Return the current symbol the cursor is on at POINT in a list.
     This will include a list of type/field names when applicable.
     This function can be overloaded (see "define-mode-local-override"
     for details).

 -- Function: semantic-ctxt-current-assignment &optional point
     Return the current assignment near the cursor at POINT.  Return a
     list as per "semantic-ctxt-current-symbol".  Return `nil' if there
     is nothing relevant.  This function can be overloaded (see
     "define-mode-local-override" for details).

 -- Function: semantic-ctxt-current-function &optional point
     Return the current function call the cursor is in at POINT.  The
     function returned is the one accepting the arguments that the
     cursor is currently in.  It will not return function symbol if the
     cursor is on the text representing that function.  This function
     can be overloaded (see "define-mode-local-override" for details).

 -- Function: semantic-ctxt-current-argument &optional point
     Return the index of the argument position the cursor is on at
     POINT.  This function can be overloaded (see
     "define-mode-local-override" for details).

 -- Function: semantic-ctxt-current-thing
     Calculate a thing identified by the current cursor position.
     Calls previously defined `semantic-ctxt-current-...' calls until
     something gets a match.  See "semantic-ctxt-current-symbol",
     "semantic-ctxt-current-function", and
     "semantic-ctxt-current-assignment" for details on the return value.

 -- Function: semantic-ctxt-current-class-list &optional point
     Return a list of tag classes that are allowed at POINT.  If POINT
     is `nil', the current buffer location is used.  For example, in
     Emacs Lisp, the symbol after a ( is most likely a function.  In a
     makefile, symbols after a : are rules, and symbols after a $( are
     variables.  This function can be overloaded (see
     "define-mode-local-override" for details).

 -- Function: semantic-ctxt-scoped-types &optional point
     Return a list of type names currently in scope at POINT.  The
     return value can be a mixed list of either strings (names of types
     that are in scope) or actual tags (type declared locally that may
     or may not have a name.)  This function can be overloaded (see
     "define-mode-local-override" for details).


File: semantic-appdev.info,  Node: Context Analysis,  Prev: Derived Context,  Up: Current Context

12.4 Analysis of the current context
====================================

The context parsing API is used in a context analysis library.  This
library provides high level routines for scanning through token
databases to create lists of token associates.  At it's core is a set
of EIEIO classes defining a context.  The context contains information
about what was parsed at a given position, such as the strings there,
and they type of assignment.  The analysis library then searches the
databases to determine the types and names available.

Two high level functions which can be run interactively are:

 -- Command: semantic-analyze-current-context &optional position
     Analyze the current context at optional POSITION.  If called
     interactively, display interesting information about POSITION in a
     separate buffer.  Returns an object based on symbol
     "semantic-analyze-context".

     This function can be overriden with the symbol `analyze-context'.
     When overriding this function, your override will be called while
     cursor is at POSITION.  In addition, your function will not be
     called if a cached copy of the return object is found.  This
     function can be overloaded (see "define-mode-local-override" for
     details).

 -- Command: semantic-analyze-possible-completions context
     Return a list of semantic tags which are possible completions.
     CONTEXT is either a position (such as point), or a precalculated
     context.  Passing in a context is useful if the caller also needs
     to access parts of the analysis.  Completions run through the
     following filters:

        * Elements currently in scope

        * Constants currently in scope

        * Elements match the `:prefix' in the CONTEXT.

        * Type of the completion matches the type of the context.

     Context type matching can identify the following:

        * No specific type

        * Assignment into a variable of some type.

        * Argument to a function with type constraints.

     When called interactively, displays the list of possible
     completions in a buffer.  This function can be overloaded (see
     "define-mode-local-override" for details).

* Menu:

* Analysis Overview::           A description of how the analyzer works.
* Analysis Objects::            What is in the analysis object.
* Completion Overview::         How completions are calculated.


File: semantic-appdev.info,  Node: Analysis Overview,  Next: Analysis Objects,  Up: Context Analysis

12.4.1 Analysis Overview
------------------------

The semantic analysis function "semantic-analye-current-context"
creates an Analysis Object.  See *Note Analysis Objects::.  This object
contains many useful pieces of information needed to do any other kind
of intelligent action on the local context.

If you call this function interactively, it will popup a buffer with a
summary of the return value.  This is useful when debugging.

     +--------+   +----------------+      +-----------------+
     | Buffer |---| Context Parser |------|   Scope Object  |
     +--------+   +----------------+      +-----------------+
         |                                        |
     +--------+   +-----------+                   |
     | Parser |---| Tag Table |---------------+   |
     +--------+   +-----------+               |   |
                                              |   |
                                              |   |
                  +-----------+               |   |
              +-->| Typecache |-----------+   |   |
              |   +-----------+           |   |   |
              |                           |   |   |
              |                           V   V   V
     +-------------+                     +-------------------+
     | Semantic DB |-------------------->| Semantic Analyzer |
     +-------------+                     +-------------------+
                                                  |
                                                  V
                                          +-----------------+
                                          | Analysis Object |
                                          +-----------------+


File: semantic-appdev.info,  Node: Analysis Objects,  Next: Completion Overview,  Prev: Analysis Overview,  Up: Context Analysis

12.4.2 Analysis Objects
-----------------------

NOTE: Need to regenerate this section


File: semantic-appdev.info,  Node: Completion Overview,  Prev: Analysis Objects,  Up: Context Analysis

12.4.3 Completion Overview
--------------------------

NOTE: Need to write this section too.


File: semantic-appdev.info,  Node: Data Debugger,  Next: GNU Free Documentation License,  Prev: Current Context,  Up: Top

13 Data structure debugger
**************************

The data structures that semantic provides can be complex, and figuring
out why some level of application API performs incorrectly can be
difficult.

The data debugger is provided by `data-debug.el' which is independent
of semantic, though semantic extends it for tag structures and objects
it provides.

The data debugger provides a way to look inside the various data
structures of Semantic in a structures and complete way to help
identify what a problem may be.

When using `edebug' to interactively debug a function, the key `E' is
bound to `data-debug-edebug-expr', which will provide a buffer with the
evaluated expression shown in it.

 -- Command: data-debug-edebug-expr expr
     Dump out the context of some expression EXPR in edebug with ddebug.

13.1 App Debugger Entry Points
==============================

There are a few basic functions that enter into the debugger.  For
historical reasons, the semantic functions use the name `adebug' to
specify functions that use the data debugger.

 -- Command: semantic-adebug-bovinate
     The same as "bovinate". Display the results in a debug buffer.

 -- Command: semantic-adebug-searchdb regex
     Search the semanticdb for REGEX for the current buffer.  Display
     the results as a debug list.

 -- Command: semantic-adebug-analyze
     Perform "semantic-analyze-current-context".  Display the results
     as a debug list.

13.2 data-debug mode
====================

The semantic adebug API now sits on `data-debug' mode, which provides a
simple user facing UI for looking into the data structures.

 -- Command: data-debug-mode
     Major-mode for the Data Debugging.

     Keybindings:
    `spc'
          Expand or contract

    `N'
          Next entry, and expand/contract.

    `P'
          Previous entry, and expand/contract.

    `n'
          Next entry

    `p'
          Next entry

    `<mouse-2>'
          Expand/Contract entries.


13.3 Create new debugger entry commands
=======================================

Creating a new Application debugger entry point is easy.  First, get a
datastructure you need to analyze.

The first function to call is:

 -- Function: data-debug-new-buffer name
     Create a new ddebug buffer with NAME.

Next, you need to find the correct function for inserting your
datastructure.  All adebug insertion functions are of the form
`data-debug-insert-THING', where THING is either the word `thing', or
whatever your object is.  Use Emacs help to pick something out.

 -- Function: data-debug-insert-thing thing prefix prebuttontext
          &optional parent
     Insert THING with PREFIX.  PREBUTTONTEXT is some text to insert
     between prefix and the thing that is not included in the
     indentation calculation of any children.  If PARENT is non-`nil',
     it is somehow related as a parent to thing.


File: semantic-appdev.info,  Node: GNU Free Documentation License,  Next: Index,  Prev: Data Debugger,  Up: Top

Appendix A GNU Free Documentation License
*****************************************

                        Version 1.1, March 2000

     Copyright (C) 2000  Free Software Foundation, Inc.
     51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA

     Everyone is permitted to copy and distribute verbatim copies
     of this license document, but changing it is not allowed.


  0. PREAMBLE

     The purpose of this License is to make a manual, textbook, or other
     written document "free" in the sense of freedom: to assure everyone
     the effective freedom to copy and redistribute it, with or without
     modifying it, either commercially or noncommercially.  Secondarily,
     this License preserves for the author and publisher a way to get
     credit for their work, while not being considered responsible for
     modifications made by others.

     This License is a kind of "copyleft", which means that derivative
     works of the document must themselves be free in the same sense.
     It complements the GNU General Public License, which is a copyleft
     license designed for free software.

     We have designed this License in order to use it for manuals for
     free software, because free software needs free documentation: a
     free program should come with manuals providing the same freedoms
     that the software does.  But this License is not limited to
     software manuals; it can be used for any textual work, regardless
     of subject matter or whether it is published as a printed book.
     We recommend this License principally for works whose purpose is
     instruction or reference.


  1. APPLICABILITY AND DEFINITIONS

     This License applies to any manual or other work that contains a
     notice placed by the copyright holder saying it can be distributed
     under the terms of this License.  The "Document", below, refers to
     any such manual or work.  Any member of the public is a licensee,
     and is addressed as "you".

     A "Modified Version" of the Document means any work containing the
     Document or a portion of it, either copied verbatim, or with
     modifications and/or translated into another language.

     A "Secondary Section" is a named appendix or a front-matter
     section of the Document that deals exclusively with the
     relationship of the publishers or authors of the Document to the
     Document's overall subject (or to related matters) and contains
     nothing that could fall directly within that overall subject.
     (For example, if the Document is in part a textbook of
     mathematics, a Secondary Section may not explain any mathematics.)
     The relationship could be a matter of historical connection with
     the subject or with related matters, or of legal, commercial,
     philosophical, ethical or political position regarding them.

     The "Invariant Sections" are certain Secondary Sections whose
     titles are designated, as being those of Invariant Sections, in
     the notice that says that the Document is released under this
     License.

     The "Cover Texts" are certain short passages of text that are
     listed, as Front-Cover Texts or Back-Cover Texts, in the notice
     that says that the Document is released under this License.

     A "Transparent" copy of the Document means a machine-readable copy,
     represented in a format whose specification is available to the
     general public, whose contents can be viewed and edited directly
     and straightforwardly with generic text editors or (for images
     composed of pixels) generic paint programs or (for drawings) some
     widely available drawing editor, and that is suitable for input to
     text formatters or for automatic translation to a variety of
     formats suitable for input to text formatters.  A copy made in an
     otherwise Transparent file format whose markup has been designed
     to thwart or discourage subsequent modification by readers is not
     Transparent.  A copy that is not "Transparent" is called "Opaque".

     Examples of suitable formats for Transparent copies include plain
     ASCII without markup, Texinfo input format, LaTeX input format,
     SGML or XML using a publicly available DTD, and
     standard-conforming simple HTML designed for human modification.
     Opaque formats include PostScript, PDF, proprietary formats that
     can be read and edited only by proprietary word processors, SGML
     or XML for which the DTD and/or processing tools are not generally
     available, and the machine-generated HTML produced by some word
     processors for output purposes only.

     The "Title Page" means, for a printed book, the title page itself,
     plus such following pages as are needed to hold, legibly, the
     material this License requires to appear in the title page.  For
     works in formats which do not have any title page as such, "Title
     Page" means the text near the most prominent appearance of the
     work's title, preceding the beginning of the body of the text.

  2. VERBATIM COPYING

     You may copy and distribute the Document in any medium, either
     commercially or noncommercially, provided that this License, the
     copyright notices, and the license notice saying this License
     applies to the Document are reproduced in all copies, and that you
     add no other conditions whatsoever to those of this License.  You
     may not use technical measures to obstruct or control the reading
     or further copying of the copies you make or distribute.  However,
     you may accept compensation in exchange for copies.  If you
     distribute a large enough number of copies you must also follow
     the conditions in section 3.

     You may also lend copies, under the same conditions stated above,
     and you may publicly display copies.

  3. COPYING IN QUANTITY

     If you publish printed copies of the Document numbering more than
     100, and the Document's license notice requires Cover Texts, you
     must enclose the copies in covers that carry, clearly and legibly,
     all these Cover Texts: Front-Cover Texts on the front cover, and
     Back-Cover Texts on the back cover.  Both covers must also clearly
     and legibly identify you as the publisher of these copies.  The
     front cover must present the full title with all words of the
     title equally prominent and visible.  You may add other material
     on the covers in addition.  Copying with changes limited to the
     covers, as long as they preserve the title of the Document and
     satisfy these conditions, can be treated as verbatim copying in
     other respects.

     If the required texts for either cover are too voluminous to fit
     legibly, you should put the first ones listed (as many as fit
     reasonably) on the actual cover, and continue the rest onto
     adjacent pages.

     If you publish or distribute Opaque copies of the Document
     numbering more than 100, you must either include a
     machine-readable Transparent copy along with each Opaque copy, or
     state in or with each Opaque copy a publicly-accessible
     computer-network location containing a complete Transparent copy
     of the Document, free of added material, which the general
     network-using public has access to download anonymously at no
     charge using public-standard network protocols.  If you use the
     latter option, you must take reasonably prudent steps, when you
     begin distribution of Opaque copies in quantity, to ensure that
     this Transparent copy will remain thus accessible at the stated
     location until at least one year after the last time you
     distribute an Opaque copy (directly or through your agents or
     retailers) of that edition to the public.

     It is requested, but not required, that you contact the authors of
     the Document well before redistributing any large number of
     copies, to give them a chance to provide you with an updated
     version of the Document.

  4. MODIFICATIONS

     You may copy and distribute a Modified Version of the Document
     under the conditions of sections 2 and 3 above, provided that you
     release the Modified Version under precisely this License, with
     the Modified Version filling the role of the Document, thus
     licensing distribution and modification of the Modified Version to
     whoever possesses a copy of it.  In addition, you must do these
     things in the Modified Version:

     A. Use in the Title Page (and on the covers, if any) a title
     distinct    from that of the Document, and from those of previous
     versions    (which should, if there were any, be listed in the
     History section    of the Document).  You may use the same title
     as a previous version    if the original publisher of that version
     gives permission.
     B. List on the Title Page, as authors, one or more persons or
     entities    responsible for authorship of the modifications in the
     Modified    Version, together with at least five of the principal
     authors of the    Document (all of its principal authors, if it
     has less than five).
     C. State on the Title page the name of the publisher of the
     Modified Version, as the publisher.
     D. Preserve all the copyright notices of the Document.
     E. Add an appropriate copyright notice for your modifications
     adjacent to the other copyright notices.
     F. Include, immediately after the copyright notices, a license
     notice    giving the public permission to use the Modified Version
     under the    terms of this License, in the form shown in the
     Addendum below.
     G. Preserve in that license notice the full lists of Invariant
     Sections    and required Cover Texts given in the Document's
     license notice.
     H. Include an unaltered copy of this License.
     I. Preserve the section entitled "History", and its title, and add
     to    it an item stating at least the title, year, new authors, and
       publisher of the Modified Version as given on the Title Page.
     If    there is no section entitled "History" in the Document,
     create one    stating the title, year, authors, and publisher of
     the Document as    given on its Title Page, then add an item
     describing the Modified    Version as stated in the previous
     sentence.
     J. Preserve the network location, if any, given in the Document for
       public access to a Transparent copy of the Document, and
     likewise    the network locations given in the Document for
     previous versions    it was based on.  These may be placed in the
     "History" section.     You may omit a network location for a work
     that was published at    least four years before the Document
     itself, or if the original    publisher of the version it refers
     to gives permission.
     K. In any section entitled "Acknowledgements" or "Dedications",
     preserve the section's title, and preserve in the section all the
      substance and tone of each of the contributor acknowledgements
     and/or dedications given therein.
     L. Preserve all the Invariant Sections of the Document,
     unaltered in their text and in their titles.  Section numbers
     or the equivalent are not considered part of the section titles.
     M. Delete any section entitled "Endorsements".  Such a section
     may not be included in the Modified Version.
     N. Do not retitle any existing section as "Endorsements"    or to
     conflict in title with any Invariant Section.

     If the Modified Version includes new front-matter sections or
     appendices that qualify as Secondary Sections and contain no
     material copied from the Document, you may at your option
     designate some or all of these sections as invariant.  To do this,
     add their titles to the list of Invariant Sections in the Modified
     Version's license notice.  These titles must be distinct from any
     other section titles.

     You may add a section entitled "Endorsements", provided it contains
     nothing but endorsements of your Modified Version by various
     parties-for example, statements of peer review or that the text has
     been approved by an organization as the authoritative definition
     of a standard.

     You may add a passage of up to five words as a Front-Cover Text,
     and a passage of up to 25 words as a Back-Cover Text, to the end
     of the list of Cover Texts in the Modified Version.  Only one
     passage of Front-Cover Text and one of Back-Cover Text may be
     added by (or through arrangements made by) any one entity.  If the
     Document already includes a cover text for the same cover,
     previously added by you or by arrangement made by the same entity
     you are acting on behalf of, you may not add another; but you may
     replace the old one, on explicit permission from the previous
     publisher that added the old one.

     The author(s) and publisher(s) of the Document do not by this
     License give permission to use their names for publicity for or to
     assert or imply endorsement of any Modified Version.

  5. COMBINING DOCUMENTS

     You may combine the Document with other documents released under
     this License, under the terms defined in section 4 above for
     modified versions, provided that you include in the combination
     all of the Invariant Sections of all of the original documents,
     unmodified, and list them all as Invariant Sections of your
     combined work in its license notice.

     The combined work need only contain one copy of this License, and
     multiple identical Invariant Sections may be replaced with a single
     copy.  If there are multiple Invariant Sections with the same name
     but different contents, make the title of each such section unique
     by adding at the end of it, in parentheses, the name of the
     original author or publisher of that section if known, or else a
     unique number.  Make the same adjustment to the section titles in
     the list of Invariant Sections in the license notice of the
     combined work.

     In the combination, you must combine any sections entitled
     "History" in the various original documents, forming one section
     entitled "History"; likewise combine any sections entitled
     "Acknowledgements", and any sections entitled "Dedications".  You
     must delete all sections entitled "Endorsements."

  6. COLLECTIONS OF DOCUMENTS

     You may make a collection consisting of the Document and other
     documents released under this License, and replace the individual
     copies of this License in the various documents with a single copy
     that is included in the collection, provided that you follow the
     rules of this License for verbatim copying of each of the
     documents in all other respects.

     You may extract a single document from such a collection, and
     distribute it individually under this License, provided you insert
     a copy of this License into the extracted document, and follow
     this License in all other respects regarding verbatim copying of
     that document.

  7. AGGREGATION WITH INDEPENDENT WORKS

     A compilation of the Document or its derivatives with other
     separate and independent documents or works, in or on a volume of
     a storage or distribution medium, does not as a whole count as a
     Modified Version of the Document, provided no compilation
     copyright is claimed for the compilation.  Such a compilation is
     called an "aggregate", and this License does not apply to the
     other self-contained works thus compiled with the Document, on
     account of their being thus compiled, if they are not themselves
     derivative works of the Document.

     If the Cover Text requirement of section 3 is applicable to these
     copies of the Document, then if the Document is less than one
     quarter of the entire aggregate, the Document's Cover Texts may be
     placed on covers that surround only the Document within the
     aggregate.  Otherwise they must appear on covers around the whole
     aggregate.

  8. TRANSLATION

     Translation is considered a kind of modification, so you may
     distribute translations of the Document under the terms of section
     4.  Replacing Invariant Sections with translations requires special
     permission from their copyright holders, but you may include
     translations of some or all Invariant Sections in addition to the
     original versions of these Invariant Sections.  You may include a
     translation of this License provided that you also include the
     original English version of this License.  In case of a
     disagreement between the translation and the original English
     version of this License, the original English version will prevail.

  9. TERMINATION

     You may not copy, modify, sublicense, or distribute the Document
     except as expressly provided for under this License.  Any other
     attempt to copy, modify, sublicense or distribute the Document is
     void, and will automatically terminate your rights under this
     License.  However, parties who have received copies, or rights,
     from you under this License will not have their licenses
     terminated so long as such parties remain in full compliance.

 10. FUTURE REVISIONS OF THIS LICENSE

     The Free Software Foundation may publish new, revised versions of
     the GNU Free Documentation License from time to time.  Such new
     versions will be similar in spirit to the present version, but may
     differ in detail to address new problems or concerns.  See
     http://www.gnu.org/copyleft/.

     Each version of the License is given a distinguishing version
     number.  If the Document specifies that a particular numbered
     version of this License "or any later version" applies to it, you
     have the option of following the terms and conditions either of
     that specified version or of any later version that has been
     published (not as a draft) by the Free Software Foundation.  If
     the Document does not specify a version number of this License,
     you may choose any version ever published (not as a draft) by the
     Free Software Foundation.


ADDENDUM: How to use this License for your documents
====================================================

To use this License in a document you have written, include a copy of
the License in the document and put the following copyright and license
notices just after the title page:


       Copyright (C)  YEAR  YOUR NAME.
       Permission is granted to copy, distribute and/or modify this document
       under the terms of the GNU Free Documentation License, Version 1.1
       or any later version published by the Free Software Foundation;
       with the Invariant Sections being LIST THEIR TITLES, with the
       Front-Cover Texts being LIST, and with the Back-Cover Texts being LIST.
       A copy of the license is included in the section entitled ``GNU
       Free Documentation License''.
If you have no Invariant Sections, write "with no Invariant
Sections" instead of saying which ones are invariant.  If you have no
Front-Cover Texts, write "no Front-Cover Texts" instead of "Front-Cover
Texts being LIST"; likewise for Back-Cover Texts.

If your document contains nontrivial examples of program code, we
recommend releasing these examples in parallel under your choice of
free software license, such as the GNU General Public License, to
permit their use in free software.


File: semantic-appdev.info,  Node: Index,  Prev: GNU Free Documentation License,  Up: Top

Index
*****

 [index ]
* Menu:

* data-debug-edebug-expr:                Data Debugger.       (line  23)
* data-debug-insert-thing:               Data Debugger.       (line  90)
* data-debug-mode:                       Data Debugger.       (line  50)
* data-debug-new-buffer:                 Data Debugger.       (line  81)
* defconst-mode-local:                   Making New Methods.  (line  62)
* defcustom-mode-local-semantic-dependency-system-include-path: DB Search Paths.
                                                              (line 111)
* define-mode-local-override:            Making New Methods.  (line  44)
* define-overloadable-function:          Making New Methods.  (line  19)
* define-semantic-idle-service:          Idle Scheduling.     (line  31)
* defvar-mode-local:                     Making New Methods.  (line  58)
* Misc Tag Functions:                    Misc Tag Functions.  (line   6)
* semantic--find-tags-by-function:       Custom Search.       (line  13)
* semantic--find-tags-by-macro:          Custom Search.       (line  18)
* semantic--tag-expand:                  Misc Tag Internals.  (line  42)
* semantic--tag-expanded-p:              Misc Tag Internals.  (line  38)
* semantic--tag-get-property:            Tag Properties Internals.
                                                              (line  25)
* semantic--tag-link-cache-to-buffer:    Misc Tag Internals.  (line  34)
* semantic--tag-link-list-to-buffer:     Misc Tag Internals.  (line  26)
* semantic--tag-link-to-buffer:          Misc Tag Internals.  (line  17)
* semantic--tag-put-property:            Tag Properties Internals.
                                                              (line  15)
* semantic--tag-put-property-no-side-effect: Tag Properties Internals.
                                                              (line  35)
* semantic--tag-run-hooks <1>:           Misc Tag Internals.  (line   7)
* semantic--tag-run-hooks:               Tag Hooks.           (line  32)
* semantic--tag-unlink-cache-from-buffer: Misc Tag Internals. (line  30)
* semantic--tag-unlink-from-buffer:      Misc Tag Internals.  (line  12)
* semantic--tag-unlink-list-from-buffer: Misc Tag Internals.  (line  22)
* semantic-adebug-analyze:               Data Debugger.       (line  40)
* semantic-adebug-bovinate:              Data Debugger.       (line  33)
* semantic-adebug-searchdb:              Data Debugger.       (line  36)
* semantic-adopt-external-members:       Tag Sorting.         (line  43)
* semantic-after-partial-cache-change-hook: Parser Hooks.     (line  24)
* semantic-after-toplevel-cache-change-hook: Parser Hooks.    (line   9)
* semantic-analyze-current-context:      Context Analysis.    (line  17)
* semantic-analyze-possible-completions: Context Analysis.    (line  30)
* semantic-before-toplevel-cache-flush-hook: Parser Hooks.    (line  40)
* semantic-beginning-of-command:         Blocks.              (line  44)
* semantic-beginning-of-context:         Blocks.              (line  24)
* semantic-brute-find-first-tag-by-function: Deep Search.     (line 144)
* semantic-brute-find-first-tag-by-name: Deep Search.         (line   8)
* semantic-brute-find-innermost-tag-by-position: Deep Search. (line  69)
* semantic-brute-find-tag-by-attribute:  Deep Search.         (line  32)
* semantic-brute-find-tag-by-attribute-value: Deep Search.    (line  44)
* semantic-brute-find-tag-by-class:      Deep Search.         (line  83)
* semantic-brute-find-tag-by-function:   Deep Search.         (line 123)
* semantic-brute-find-tag-by-position:   Deep Search.         (line  58)
* semantic-brute-find-tag-by-property:   Deep Search.         (line  21)
* semantic-brute-find-tag-by-type:       Deep Search.         (line 110)
* semantic-brute-find-tag-standard:      Deep Search.         (line  98)
* semantic-bucketize:                    Tag Sorting.         (line  23)
* semantic-bucketize-tag-class:          Tag Sorting.         (line  34)
* semantic-collector-abstract:           Tag Collectors.      (line  17)
* semantic-collector-analyze-completions: Tag Collectors.     (line  43)
* semantic-collector-buffer-abstract:    Tag Collectors.      (line  22)
* semantic-collector-buffer-deep:        Tag Collectors.      (line  32)
* semantic-collector-project:            Tag Collectors.      (line  37)
* semantic-collector-project-abstract:   Tag Collectors.      (line  26)
* semantic-collector-project-brutish:    Tag Collectors.      (line  40)
* semantic-complete-inline-analyzer:     Tag Completion Convenience Functions.
                                                              (line  45)
* semantic-complete-read-tag-analyzer:   Tag Completion Convenience Functions.
                                                              (line  33)
* semantic-complete-read-tag-buffer-deep: Tag Completion Convenience Functions.
                                                              (line  11)
* semantic-complete-read-tag-engine:     Custom Tag Completion Functions.
                                                              (line  26)
* semantic-complete-read-tag-project:    Tag Completion Convenience Functions.
                                                              (line  22)
* semantic-ctxt-current-argument:        Derived Context.     (line  33)
* semantic-ctxt-current-assignment:      Derived Context.     (line  20)
* semantic-ctxt-current-class-list:      Derived Context.     (line  45)
* semantic-ctxt-current-function:        Derived Context.     (line  26)
* semantic-ctxt-current-symbol:          Derived Context.     (line  14)
* semantic-ctxt-current-thing:           Derived Context.     (line  38)
* semantic-ctxt-scoped-types:            Derived Context.     (line  53)
* semantic-current-tag:                  Tags at Point.       (line  50)
* semantic-current-tag-parent:           Tags at Point.       (line  60)
* semantic-dependency-system-include-path: Tag File Reference.
                                                              (line  11)
* semantic-dependency-tag-file:          Tag File Reference.  (line  20)
* semantic-displayor-abstract:           Tag Displayors.      (line  19)
* semantic-displayor-focus-abstract:     Tag Displayors.      (line  24)
* semantic-displayor-tooltip:            Tag Displayors.      (line  43)
* semantic-displayor-traditional:        Tag Displayors.      (line  31)
* semantic-displayor-traditional-with-focus-highlight: Tag Displayors.
                                                              (line  36)
* semantic-edits-are-safe:               Editing Buffers.     (line  10)
* semantic-end-of-command:               Blocks.              (line  39)
* semantic-end-of-context:               Blocks.              (line  30)
* semantic-equivalent-tag-p:             Tag Query.           (line  19)
* semantic-exit-on-input:                Idle Scheduling.     (line  57)
* semantic-find-first-tag-by-name:       Breadth Search.      (line  11)
* semantic-find-tag-by-overlay:          Tags at Point.       (line  16)
* semantic-find-tag-by-overlay-in-region: Tags at Point.      (line  31)
* semantic-find-tag-by-overlay-next:     Tags at Point.       (line  42)
* semantic-find-tag-by-overlay-prev:     Tags at Point.       (line  46)
* semantic-find-tags-by-class:           Breadth Search.      (line  35)
* semantic-find-tags-by-name:            Breadth Search.      (line  16)
* semantic-find-tags-by-name-regexp:     Breadth Search.      (line  28)
* semantic-find-tags-by-scope-protection: Specialty Search.   (line  17)
* semantic-find-tags-by-type:            Breadth Search.      (line  41)
* semantic-find-tags-external-children-of-type: Specialty Search.
                                                              (line  28)
* semantic-find-tags-for-completion:     Breadth Search.      (line  20)
* semantic-find-tags-included:           Breadth Search.      (line  48)
* semantic-find-tags-of-compound-type:   Specialty Search.    (line  11)
* semantic-format-tag-abbreviate:        Format Tag.          (line  47)
* semantic-format-tag-concise-prototype: Format Tag.          (line  83)
* semantic-format-tag-custom-list:       Format Tag.          (line  22)
* semantic-format-tag-functions:         Format Tag.          (line  14)
* semantic-format-tag-name:              Format Tag.          (line  36)
* semantic-format-tag-prin1:             Format Tag.          (line 128)
* semantic-format-tag-prototype:         Format Tag.          (line  69)
* semantic-format-tag-summarize:         Format Tag.          (line  59)
* semantic-format-tag-type:              Format Tag.          (line 139)
* semantic-format-tag-uml-abbreviate:    Format Tag.          (line  94)
* semantic-format-tag-uml-concise-prototype: Format Tag.      (line 117)
* semantic-format-tag-uml-prototype:     Format Tag.          (line 106)
* semantic-get-all-local-variables:      Local Variables.     (line  27)
* semantic-get-local-arguments:          Local Variables.     (line  17)
* semantic-get-local-variables:          Local Variables.     (line  11)
* semantic-go-to-tag:                    Jump to a Tag.       (line  10)
* semantic-highlight-tag:                Tag Highlighting.    (line   7)
* semantic-lex-catch-errors:             Lexical Safety.      (line  14)
* semantic-mark-external-member-function: Tag Sorting.        (line  67)
* semantic-momentary-highlight-tag:      Tag Highlighting.    (line  22)
* semantic-narrow-to-tag:                Misc Tag Functions.  (line   7)
* semantic-orphaned-member-metaparent-type: Tag Sorting.      (line  62)
* semantic-parse-tree-needs-rebuild-p:   Parser State.        (line  14)
* semantic-parse-tree-needs-update-p:    Parser State.        (line  11)
* semantic-parse-tree-unparseable-p:     Parser State.        (line  17)
* semantic-parse-tree-up-to-date-p:      Parser State.        (line  20)
* semantic-prototype-file:               Tag File Reference.  (line  34)
* semantic-read-function:                Old Tag Completion.  (line  24)
* semantic-read-symbol:                  Old Tag Completion.  (line  10)
* semantic-read-type:                    Old Tag Completion.  (line  30)
* semantic-read-variable:                Old Tag Completion.  (line  18)
* semantic-set-tag-face:                 Tag Highlighting.    (line  34)
* semantic-set-tag-folded:               Tag Folding.         (line  10)
* semantic-set-tag-intangible:           Tag Visible Properties.
                                                              (line  26)
* semantic-set-tag-invisible:            Tag Visible Properties.
                                                              (line  11)
* semantic-set-tag-read-only:            Tag Visible Properties.
                                                              (line  45)
* semantic-tag:                          Creating Tags.       (line   7)
* semantic-tag-abstract-p:               Tag Details.         (line  48)
* semantic-tag-add-hook:                 Tag Hooks.           (line  13)
* semantic-tag-attributes:               Tag Attributes Internals.
                                                              (line   7)
* semantic-tag-bounds:                   Tag Overlay.         (line  24)
* semantic-tag-buffer:                   Tag Overlay.         (line  35)
* semantic-tag-children-compatibility:   Tag Query.           (line 243)
* semantic-tag-class:                    Tag Basics.          (line  64)
* semantic-tag-clone:                    Copying Tags.        (line  15)
* semantic-tag-code-detail:              Tag Query.           (line 224)
* semantic-tag-components <1>:           Tag Members.         (line  12)
* semantic-tag-components:               Tag Query.           (line 231)
* semantic-tag-components-default:       Tag Query.           (line 238)
* semantic-tag-components-with-overlays <1>: Tag Members.     (line  19)
* semantic-tag-components-with-overlays: Tag Overlay.         (line  67)
* semantic-tag-components-with-overlays-default: Tag Overlay. (line  81)
* semantic-tag-copy:                     Copying Tags.        (line  22)
* semantic-tag-create-secondary-overlay: Tag Secondary Overlays.
                                                              (line  21)
* semantic-tag-deep-copy-one-tag:        Copying Tags.        (line  30)
* semantic-tag-delete-secondary-overlay: Tag Secondary Overlays.
                                                              (line  29)
* semantic-tag-docstring:                Tag Query.           (line  56)
* semantic-tag-end:                      Tag Overlay.         (line  18)
* semantic-tag-external-member-children: Tag Members.         (line  54)
* semantic-tag-external-member-p:        Tag Members.         (line  36)
* semantic-tag-faux-p:                   Tag Query.           (line  40)
* semantic-tag-file-name:                Tag Overlay.         (line  44)
* semantic-tag-folded-p:                 Tag Folding.         (line  15)
* semantic-tag-function-arguments:       Tag Query.           (line 111)
* semantic-tag-function-destructor-p:    Tag Query.           (line  77)
* semantic-tag-function-parent:          Tag Query.           (line 159)
* semantic-tag-function-throws:          Tag Query.           (line  85)
* semantic-tag-get-attribute:            Tag Attributes Internals.
                                                              (line  27)
* semantic-tag-get-secondary-overlay:    Tag Secondary Overlays.
                                                              (line  38)
* semantic-tag-in-buffer-p:              Tag Overlay.         (line  31)
* semantic-tag-include-filename:         Tag Query.           (line 210)
* semantic-tag-include-system-p:         Tag Query.           (line 202)
* semantic-tag-intangible-p:             Tag Visible Properties.
                                                              (line  36)
* semantic-tag-invisible-p:              Tag Visible Properties.
                                                              (line  19)
* semantic-tag-leaf-p:                   Tag Details.         (line  64)
* semantic-tag-make-plist:               Tag Properties Internals.
                                                              (line  47)
* semantic-tag-modifiers:                Tag Query.           (line  93)
* semantic-tag-name:                     Tag Basics.          (line  55)
* semantic-tag-named-parent:             Tag Query.           (line 153)
* semantic-tag-new-code:                 Creating Tags.       (line  82)
* semantic-tag-new-function:             Creating Tags.       (line  29)
* semantic-tag-new-include:              Creating Tags.       (line  61)
* semantic-tag-new-package:              Creating Tags.       (line  72)
* semantic-tag-new-type:                 Creating Tags.       (line  41)
* semantic-tag-new-variable:             Creating Tags.       (line  17)
* semantic-tag-of-class-p:               Tag Query.           (line  37)
* semantic-tag-of-type-p:                Tag Query.           (line 142)
* semantic-tag-overlay:                  Tag Overlay.         (line  50)
* semantic-tag-p:                        Tag Query.           (line  13)
* semantic-tag-properties:               Tag Properties Internals.
                                                              (line   7)
* semantic-tag-protected-p:              Tag Details.         (line  30)
* semantic-tag-protection:               Tag Details.         (line  10)
* semantic-tag-put-attribute:            Tag Attributes Internals.
                                                              (line  44)
* semantic-tag-put-attribute-no-side-effect: Tag Attributes Internals.
                                                              (line  55)
* semantic-tag-read-only-p:              Tag Visible Properties.
                                                              (line  54)
* semantic-tag-remove-hook:              Tag Hooks.           (line  21)
* semantic-tag-secondary-overlays:       Tag Secondary Overlays.
                                                              (line  42)
* semantic-tag-set-bounds:               Tag Overlay Internals.
                                                              (line  10)
* semantic-tag-similar-p:                Tag Query.           (line  30)
* semantic-tag-start:                    Tag Overlay.         (line  11)
* semantic-tag-static-p:                 Tag Details.         (line  77)
* semantic-tag-type:                     Tag Query.           (line 133)
* semantic-tag-type-compound-p:          Tag Query.           (line  48)
* semantic-tag-type-interfaces:          Tag Query.           (line 180)
* semantic-tag-type-members:             Tag Query.           (line 191)
* semantic-tag-type-superclasses:        Tag Query.           (line 169)
* semantic-tag-variable-constant-p:      Tag Query.           (line  69)
* semantic-tag-variable-default:         Tag Query.           (line 122)
* semantic-tag-with-position-p:          Tag Overlay.         (line  60)
* semantic-texi-find-documentation:      Tag File Reference.  (line  44)
* semantic-throw-on-input:               Idle Scheduling.     (line  47)
* semantic-unhighlight-tag:              Tag Highlighting.    (line  15)
* semantic-unique-tag-table:             Tag Sorting.         (line  14)
* semantic-unique-tag-table-by-name:     Tag Sorting.         (line  19)
* semantic-up-context:                   Blocks.              (line  13)
* semantic-with-buffer-narrowed-to-current-tag: Misc Tag Functions.
                                                              (line  15)
* semantic-with-buffer-narrowed-to-tag:  Misc Tag Functions.  (line  23)
* semantic-with-mode-bindings:           Override Methods.    (line  18)
* semanticdb-brute-deep-find-tags-by-name: DB Basic Brute Search.
                                                              (line  11)
* semanticdb-check-references:           Semanticdb references.
                                                              (line  34)
* semanticdb-create-ebrowse-database:    System Databases.    (line  26)
* semanticdb-deep-find-tags-by-name:     DB Basic Name Search.
                                                              (line  45)
* semanticdb-deep-find-tags-by-name-regexp: DB Basic Name Search.
                                                              (line  53)
* semanticdb-deep-find-tags-for-completion: DB Basic Name Search.
                                                              (line  61)
* semanticdb-fast-strip-find-results:    DB Results.          (line  27)
* semanticdb-file-stream:                Semanticdb in Programs.
                                                              (line  21)
* semanticdb-file-table-object:          Semanticdb in Programs.
                                                              (line  28)
* semanticdb-find-default-throttle:      DB Search Paths.     (line  17)
* semanticdb-find-result-length:         DB Results.          (line  51)
* semanticdb-find-result-mapc:           DB Results.          (line  69)
* semanticdb-find-result-nth:            DB Results.          (line  54)
* semanticdb-find-result-nth-in-buffer:  DB Results.          (line  62)
* semanticdb-find-result-with-nil-p:     DB Results.          (line  41)
* semanticdb-find-results-p:             DB Results.          (line  36)
* semanticdb-find-table-for-include:     DB Search Paths.     (line  94)
* semanticdb-find-tags-by-class:         DB Basic Name Search.
                                                              (line  36)
* semanticdb-find-tags-by-name:          DB Basic Name Search.
                                                              (line  15)
* semanticdb-find-tags-by-name-regexp:   DB Basic Name Search.
                                                              (line  22)
* semanticdb-find-tags-collector:        DB Generic Search.   (line  12)
* semanticdb-find-tags-external-children-of-type: DB Advanced Search.
                                                              (line  17)
* semanticdb-find-tags-for-completion:   DB Basic Name Search.
                                                              (line  29)
* semanticdb-find-translate-path:        DB Search Paths.     (line  58)
* semanticdb-get-typecache:              DB Data Type Search. (line  20)
* semanticdb-have-typecache-p:           DB Data Type Search. (line  16)
* semanticdb-includes-in-table:          Semanticdb references.
                                                              (line  20)
* semanticdb-minor-mode-p:               Semanticdb in Programs.
                                                              (line  10)
* semanticdb-notify-references:          Semanticdb references.
                                                              (line  26)
* semanticdb-project-database-ebrowse:   System Databases.    (line  20)
* semanticdb-project-database-emacs-lisp: System Databases.   (line  15)
* semanticdb-ref-test:                   Semanticdb references.
                                                              (line  41)
* semanticdb-strip-find-results:         DB Results.          (line  18)
* semanticdb-typecache-dump:             DB Data Type Search. (line  36)
* semanticdb-typecache-find:             DB Data Type Search. (line  27)
* setq-mode-local:                       Making New Methods.  (line  70)
* Tag Basics:                            Tag Basics.          (line   6)
* Tag Hooks:                             Tag Hooks.           (line   6)
* Tag Internals:                         Tag Internals.       (line   6)
* Tag Overlay:                           Tag Overlay.         (line   6)
* Tag Query:                             Tag Query.           (line   6)



Tag Table:
Node: Top1136
Node: Semantic Tags2757
Node: Tag Basics3340
Ref: semantic-tag-name5713
Ref: semantic-tag-class6170
Node: Tag Query7632
Ref: semantic-tag-p7925
Ref: semantic-equivalent-tag-p8169
Ref: semantic-tag-similar-p8669
Ref: semantic-tag-of-class-p8981
Ref: semantic-tag-faux-p9068
Ref: semantic-tag-type-compound-p9426
Ref: semantic-tag-docstring9691
Ref: semantic-tag-variable-constant-p10173
Ref: semantic-tag-function-destructor-p10526
Ref: semantic-tag-function-throws10873
Ref: semantic-tag-modifiers11202
Ref: semantic-tag-function-arguments11835
Ref: semantic-tag-variable-default12201
Ref: semantic-tag-type12566
Ref: semantic-tag-of-type-p13021
Ref: semantic-tag-named-parent13496
Ref: semantic-tag-function-parent13780
Ref: semantic-tag-type-superclasses14238
Ref: semantic-tag-type-interfaces14694
Ref: semantic-tag-type-members15140
Ref: semantic-tag-include-system-p15487
Ref: semantic-tag-include-filename15836
Ref: semantic-tag-code-detail16388
Ref: semantic-tag-components16585
Ref: semantic-tag-components-default16963
Ref: semantic-tag-children-compatibility17156
Node: Tag Overlay17572
Ref: semantic-tag-start17954
Ref: semantic-tag-end18175
Ref: semantic-tag-bounds18388
Ref: semantic-tag-in-buffer-p18640
Ref: semantic-tag-buffer18797
Ref: semantic-tag-file-name19176
Ref: semantic-tag-overlay19486
Ref: semantic-tag-with-position-p19929
Ref: semantic-tag-components-with-overlays20209
Ref: semantic-tag-components-with-overlays-default20883
Node: Tag Hooks21129
Ref: semantic-tag-add-hook21550
Ref: semantic-tag-remove-hook21958
Ref: semantic--tag-run-hooks22488
Node: Misc Tag Functions23466
Ref: semantic-narrow-to-tag23682
Ref: semantic-with-buffer-narrowed-to-current-tag23998
Ref: semantic-with-buffer-narrowed-to-tag24331
Node: Tag Internals24552
Node: Tag Attributes Internals24840
Ref: semantic-tag-attributes25061
Ref: semantic-tag-get-attribute25895
Ref: semantic-tag-put-attribute26649
Ref: semantic-tag-put-attribute-no-side-effect27164
Node: Tag Properties Internals27486
Ref: semantic-tag-properties27737
Ref: semantic--tag-put-property28079
Ref: semantic--tag-get-property28505
Ref: semantic--tag-put-property-no-side-effect28922
Ref: semantic-tag-make-plist29511
Node: Tag Overlay Internals30070
Ref: semantic-tag-set-bounds30412
Node: Creating Tags30479
Ref: semantic-tag30698
Ref: semantic-tag-new-variable31193
Ref: semantic-tag-new-function31765
Ref: semantic-tag-new-type32357
Ref: semantic-tag-new-include33481
Ref: semantic-tag-new-package34022
Ref: semantic-tag-new-code34505
Node: Copying Tags34707
Ref: semantic-tag-clone35288
Ref: semantic-tag-copy35614
Ref: semantic-tag-deep-copy-one-tag36064
Node: Misc Tag Internals36320
Node: Searching Tag Tables38580
Node: Breadth Search39537
Ref: semantic-find-first-tag-by-name39931
Ref: semantic-find-tags-by-name40208
Ref: semantic-find-tags-for-completion40406
Ref: semantic-find-tags-by-name-regexp40815
Ref: semantic-find-tags-by-class41163
Ref: semantic-find-tags-by-type41440
Ref: semantic-find-tags-included41808
Node: Deep Search41939
Node: Specialty Search48826
Ref: semantic-find-tags-of-compound-type49253
Ref: semantic-find-tags-by-scope-protection49552
Ref: semantic-find-tags-external-children-of-type50146
Node: Custom Search50349
Ref: semantic--find-tags-by-function50852
Ref: semantic--find-tags-by-macro51113
Node: Tags at Point51245
Node: Tag Decoration54107
Node: Tag Highlighting54717
Ref: semantic-highlight-tag54915
Ref: semantic-unhighlight-tag55205
Ref: semantic-momentary-highlight-tag55482
Ref: semantic-set-tag-face56010
Node: Tag Visible Properties56214
Ref: semantic-set-tag-invisible56661
Ref: semantic-tag-invisible-p56971
Ref: semantic-set-tag-intangible57238
Ref: semantic-tag-intangible-p57681
Ref: semantic-set-tag-read-only58078
Ref: semantic-tag-read-only-p58440
Node: Tag Secondary Overlays58661
Ref: semantic-tag-create-secondary-overlay59440
Ref: semantic-tag-delete-secondary-overlay59863
Ref: semantic-tag-get-secondary-overlay60168
Ref: semantic-tag-secondary-overlays60350
Node: Tag Folding60924
Ref: semantic-set-tag-folded61246
Ref: semantic-tag-folded-p61467
Node: Tag Sorting61511
Ref: semantic-unique-tag-table61971
Ref: semantic-unique-tag-table-by-name62236
Ref: semantic-bucketize62421
Ref: semantic-bucketize-tag-class63045
Ref: semantic-adopt-external-members63573
Ref: semantic-orphaned-member-metaparent-type64483
Ref: semantic-mark-external-member-function64739
Node: Tag Completion65296
Node: Tag Completion Convenience Functions66322
Ref: semantic-complete-read-tag-project67349
Ref: semantic-complete-read-tag-analyzer67948
Ref: semantic-complete-inline-analyzer68654
Node: Custom Tag Completion Functions69036
Ref: semantic-complete-read-tag-engine70003
Node: Tag Collectors71681
Ref: semantic-collector-abstract72228
Ref: semantic-collector-buffer-abstract72471
Ref: semantic-collector-project-abstract72632
Ref: semantic-collector-buffer-deep72833
Ref: semantic-collector-project73044
Ref: semantic-collector-project-brutish73136
Ref: semantic-collector-analyze-completions73232
Node: Tag Displayors73476
Ref: semantic-displayor-abstract74175
Ref: semantic-displayor-focus-abstract74403
Ref: semantic-displayor-traditional74653
Ref: semantic-displayor-traditional-with-focus-highlight74908
Ref: semantic-displayor-tooltip75220
Node: Old Tag Completion75342
Ref: semantic-read-symbol75681
Ref: semantic-read-variable76139
Ref: semantic-read-function76472
Ref: semantic-read-type76799
Node: Override Methods77057
Ref: semantic-with-mode-bindings77808
Node: Format Tag78490
Ref: semantic-format-tag-functions79073
Ref: semantic-format-tag-custom-list79522
Ref: semantic-format-tag-name80184
Ref: semantic-format-tag-abbreviate80753
Ref: semantic-format-tag-summarize81399
Ref: semantic-format-tag-prototype81917
Ref: semantic-format-tag-concise-prototype82604
Ref: semantic-format-tag-uml-abbreviate83154
Ref: semantic-format-tag-uml-prototype83707
Ref: semantic-format-tag-uml-concise-prototype84258
Ref: semantic-format-tag-prin184812
Ref: semantic-format-tag-type85249
Node: Tag Members85472
Ref: semantic-tag-external-member-p87017
Ref: semantic-tag-external-member-children87861
Node: Tag Details88999
Ref: semantic-tag-protection89345
Ref: semantic-tag-protected-p90415
Ref: semantic-tag-abstract-p90901
Ref: semantic-tag-leaf-p91654
Ref: semantic-tag-static-p92286
Node: Tag File Reference92798
Ref: semantic-dependency-system-include-path93124
Ref: semantic-dependency-tag-file93584
Ref: semantic-prototype-file94253
Ref: semantic-texi-find-documentation94771
Node: Jump to a Tag95187
Ref: semantic-go-to-tag95524
Node: Making New Methods96418
Ref: define-overload97124
Ref: define-mode-local-override98361
Ref: defvar-mode-local99076
Ref: defconst-mode-local99225
Ref: setq-mode-local99549
Node: Parser Features99966
Node: Editing Buffers101150
Node: Parser State101797
Ref: semantic-parse-tree-needs-update-p102208
Ref: semantic-parse-tree-needs-rebuild-p102328
Ref: semantic-parse-tree-unparseable-p102446
Ref: semantic-parse-tree-up-to-date-p102567
Node: Parser Hooks102631
Ref: semantic-after-toplevel-cache-change-hook102903
Ref: semantic-after-partial-cache-change-hook103491
Ref: semantic-before-toplevel-cache-flush-hook104083
Node: Lexical Safety104404
Ref: semantic-lex-catch-errors104899
Node: Semantic Database105655
Node: Semanticdb in Programs106582
Ref: semanticdb-minor-mode-p106903
Ref: semanticdb-file-stream107359
Ref: semanticdb-file-table-object107698
Node: Semanticdb Tag Queries108027
Node: DB Results110031
Ref: semanticdb-strip-find-results110610
Ref: semanticdb-fast-strip-find-results111132
Ref: semanticdb-find-results-p111566
Ref: semanticdb-find-result-with-nil-p111831
Ref: semanticdb-find-result-length112305
Ref: semanticdb-find-result-nth112393
Ref: semanticdb-find-result-nth-in-buffer112771
Ref: semanticdb-find-result-mapc113111
Node: DB Search Paths113305
Ref: semanticdb-find-default-throttle114009
Ref: semanticdb-find-translate-path115591
Ref: semanticdb-find-table-for-include117379
Ref: defcustom-mode-local-semantic-dependency-system-include-path118219
Node: DB Basic Name Search118655
Ref: semanticdb-find-tags-by-name119202
Ref: semanticdb-find-tags-by-name-regexp119547
Ref: semanticdb-find-tags-for-completion119894
Ref: semanticdb-find-tags-by-class120234
Ref: semanticdb-deep-find-tags-by-name120586
Ref: semanticdb-deep-find-tags-by-name-regexp120998
Ref: semanticdb-deep-find-tags-for-completion121412
Node: DB Data Type Search121723
Ref: semanticdb-have-typecache-p122394
Ref: semanticdb-get-typecache122524
Ref: semanticdb-typecache-find122836
Ref: semanticdb-typecache-dump123259
Node: DB Basic Brute Search123308
Ref: semanticdb-brute-deep-find-tags-by-name123714
Node: DB Advanced Search124068
Ref: semanticdb-find-tags-external-children-of-type124797
Node: DB Generic Search125065
Ref: semanticdb-find-tags-collector125477
Node: System Databases126372
Ref: semanticdb-project-database-emacs-lisp126950
Ref: semanticdb-project-database-ebrowse127082
Ref: semanticdb-create-ebrowse-database127313
Node: Semanticdb references127505
Ref: semanticdb-includes-in-table128237
Ref: semanticdb-notify-references128442
Ref: semanticdb-check-references128778
Ref: semanticdb-ref-test129026
Node: Idle Scheduling129209
Ref: define-semantic-idle-service130298
Ref: semantic-throw-on-input130878
Ref: semantic-exit-on-input131334
Node: Example Programs131836
Node: Current Context132046
Node: Blocks132766
Ref: semantic-up-context133308
Ref: semantic-beginning-of-context133928
Ref: semantic-end-of-context134234
Ref: semantic-end-of-command134632
Ref: semantic-beginning-of-command134872
Node: Local Variables135074
Ref: semantic-get-local-variables135463
Ref: semantic-get-local-arguments135779
Ref: semantic-get-all-local-variables136365
Node: Derived Context136732
Ref: semantic-ctxt-current-symbol137320
Ref: semantic-ctxt-current-assignment137609
Ref: semantic-ctxt-current-function137926
Ref: semantic-ctxt-current-argument138338
Ref: semantic-ctxt-current-thing138546
Ref: semantic-ctxt-current-class-list138928
Ref: semantic-ctxt-scoped-types139370
Node: Context Analysis139697
Ref: semantic-analyze-current-context140468
Ref: semantic-analyze-possible-completions141118
Node: Analysis Overview142204
Node: Analysis Objects143983
Node: Completion Overview144203
Node: Data Debugger144403
Ref: data-debug-edebug-expr145268
Ref: semantic-adebug-bovinate145625
Ref: semantic-adebug-searchdb145738
Ref: semantic-adebug-analyze145880
Ref: semantic-adebug-mode146178
Ref: semantic-adebug-new-buffer146759
Ref: data-debug-insert-thing147156
Node: GNU Free Documentation License147408
Node: Index167152

End Tag Table
